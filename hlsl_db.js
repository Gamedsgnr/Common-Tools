const hlslData = [
    {
        "id": "hlsl_parallax_cracks",
        "title": "Parallax Cracks (POM)",
        "lang": "hlsl",
        "desc": "Эффект глубоких трещин с текстурированными стенками, свечением дна и мягкими краями.",
        "inputs": "UV, ViewDirTS, HeightTex, HeightTexSampler, HeightScale, WallHeight, RockTiling, RockTex, RockTexSampler, RockTintColor, DepthDarkness, GlowPower, GlowColor, GlowIntensity, EdgeFeather, OverallOpacity",
        "code": "// ===== Входные данные =====\nfloat2 uv = UV;\n\n// Нормализованный вектор на камеру в tangent space\nfloat3 V = normalize(ViewDirTS);\nfloat  viewZ = abs(V.z) + 1e-4;\nfloat2 parallaxDir = -V.xy / viewZ;\n\n// Базовое значение высоты и маски в исходной точке UV\nfloat4 baseSample = HeightTex.Sample(HeightTexSampler, uv);\nfloat  baseHeight = saturate(baseSample.r); // 0 = край, 1 = дно\nfloat  baseMask   = saturate(baseSample.g); // 0 = пол, 1 = трещина\n\n// Если мы совсем вне трещины — сразу прозрачность\nif (baseMask <= 0.001f)\n{\n    return float4(0.0, 0.0, 0.0, 0.0);\n}\n\n// ===== Parallax Occlusion Mapping =====\nconst int NUM_STEPS    = 24; // базовые шаги\nconst int REFINE_STEPS = 5; // уточнение\n\nfloat parallaxScale = HeightScale;\nfloat stepSize      = 1.0 / NUM_STEPS;\n\n// Направление смещения по UV\nfloat2 deltaUV = parallaxDir * parallaxScale * stepSize;\n\n// Начальные значения\nfloat  currLayerHeight = 0.0;\nfloat2 currUV = uv;\nfloat  currHeight = baseHeight;\n\nfloat2 prevUV = currUV;\nfloat  prevLayerHeight = 0.0;\nfloat  prevHeight = currHeight;\n\n// Поиск пересечения луча с высотным полем\n[loop]\nfor (int i = 0; i < NUM_STEPS; ++i)\n{\n    prevUV           = currUV;\n    prevLayerHeight  = currLayerHeight;\n    prevHeight       = currHeight;\n\n    currLayerHeight += stepSize;\n    currUV          -= deltaUV;  // идём \"в глубину\"\n    currHeight       = HeightTex.Sample(HeightTexSampler, currUV).r;\n\n    // когда высота карты стала ниже высоты слоя — мы \"зашли под поверхность\"\n    if (currHeight < currLayerHeight)\n    {\n        break;\n    }\n}\n\n// Дополнительное уточнение между prevUV и currUV\nfloat2 refinedUV = currUV;\nfloat  refinedLayerHeight = currLayerHeight;\n\nfloat2 dirRefine = (currUV - prevUV) / max((float)REFINE_STEPS, 1.0);\nfloat  hStepRef  = (currLayerHeight - prevLayerHeight) / max((float)REFINE_STEPS, 1.0);\n\nfloat2 testUV = prevUV;\nfloat  testLayer = prevLayerHeight;\nfloat  testHeight = prevHeight;\n\n[loop]\nfor (int j = 0; j < REFINE_STEPS; ++j)\n{\n    testUV    += dirRefine;\n    testLayer += hStepRef;\n    testHeight = HeightTex.Sample(HeightTexSampler, testUV).r;\n\n    if (testHeight < testLayer)\n    {\n        refinedUV = testUV;\n        refinedLayerHeight = testLayer;\n        break;\n    }\n}\n\n// Итоговые UV и \"глубина\" пересечения\nfloat2 parallaxUV = refinedUV;\nfloat  depth = saturate(refinedLayerHeight); // 0 = верх, 1 = дно\n\n// ===== Разделение на стены и дно =====\n\n// WallHeight: на какой части глубины заканчиваются стенки\nfloat wallH = saturate(WallHeight);\nwallH = max(wallH, 0.001);\n\n// Нормализованная глубина по стенке: 0 у края, 1 внизу стен\nfloat wallDepthNorm = saturate(depth / wallH);\n// Стены: от края до wallH\nfloat wallMask = saturate(1.0 - wallDepthNorm);\n\n// Дно (ядро): глубины ниже wallH\nfloat floorRegion = saturate((depth - wallH) / (1.0 - wallH + 1e-4));\n\n// ===== Текстура камня (стены) =====\nfloat2 rockUV = parallaxUV * RockTiling;\nfloat3 rockSample = RockTex.Sample(RockTexSampler, rockUV).rgb;\nfloat3 rockColor  = rockSample * RockTintColor;\n\n// Затемнение стен к низу\nfloat depthDark = saturate(DepthDarkness);\nfloat wallShade = lerp(1.0, 1.0 - depthDark, wallDepthNorm);\n\n// Итоговый цвет стен\nfloat3 wallColor = rockColor * wallShade * wallMask;\n\n// ===== Свечение дна и свет по стенам снизу вверх =====\n\n// Свечение на дне: 0 у начала дна, 1 в самой глубине\nfloat safeGlowPower = max(GlowPower, 0.0001);\nfloat glowGradFloor = pow(floorRegion, safeGlowPower);\n\n// Немного шума из B-канала (если есть)\nfloat glowNoise   = baseSample.b;\nfloat glowNoiseFactor = lerp(0.7, 1.0, glowNoise);\n\n// Свечение дна\nfloat glowFloorFactor = glowGradFloor * glowNoiseFactor;\nfloat3 glowFloorColor = GlowColor * GlowIntensity * glowFloorFactor;\n\n// Свечение по стенам: растёт от верха к низу (но слабее, чем на дне)\nfloat glowGradWalls = pow(depth, safeGlowPower);\nfloat wallGlowScale = 0.5; // насколько сильно подсвечиваются стены\nfloat3 glowWallColor = GlowColor * GlowIntensity * wallGlowScale * glowGradWalls * wallMask;\n\n// ===== Комбинируем стены + свечение =====\nfloat3 innerColor = wallColor + glowFloorColor + glowWallColor;\n\n// ===== Мягкий край по исходной маске (Feather) =====\nfloat edgeDenom = max(1.0 - EdgeFeather, 0.0001);\nfloat edgeMask  = saturate((baseHeight - EdgeFeather) / edgeDenom);\n\n// Итоговая непрозрачность\nfloat opacity = edgeMask * OverallOpacity;\nopacity = saturate(opacity);\n\n// Гасим цвет по opacity, чтобы край выглядел мягко\nfloat3 finalColor = innerColor * opacity;\n\n// Возвращаем RGBA\nreturn float4(finalColor, opacity);"
    }
];
