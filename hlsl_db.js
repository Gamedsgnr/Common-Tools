const hlslData = [
    {
        "id": "hlsl_parallax_cracks",
        "title": "Parallax Cracks (POM)",
        "lang": "hlsl",
        "desc": "Эффект глубоких трещин с текстурированными стенками, свечением дна и мягкими краями.",
        "inputs": "UV, ViewDirTS, HeightTex, HeightTexSampler, HeightScale, WallHeight, RockTiling, RockTex, RockTexSampler, RockTintColor, DepthDarkness, GlowPower, GlowColor, GlowIntensity, EdgeFeather, OverallOpacity",
        "code": "// ===== Входные данные =====\nfloat2 uv = UV;\n\n// Нормализованный вектор на камеру в tangent space\nfloat3 V = normalize(ViewDirTS);\nfloat  viewZ = abs(V.z) + 1e-4;\nfloat2 parallaxDir = -V.xy / viewZ;\n\n// Базовое значение высоты и маски в исходной точке UV\nfloat4 baseSample = HeightTex.Sample(HeightTexSampler, uv);\nfloat  baseHeight = saturate(baseSample.r); // 0 = край, 1 = дно\nfloat  baseMask   = saturate(baseSample.g); // 0 = пол, 1 = трещина\n\n// Если мы совсем вне трещины — сразу прозрачность\nif (baseMask <= 0.001f)\n{\n    return float4(0.0, 0.0, 0.0, 0.0);\n}\n\n// ===== Parallax Occlusion Mapping =====\nconst int NUM_STEPS    = 24; // базовые шаги\nconst int REFINE_STEPS = 5; // уточнение\n\nfloat parallaxScale = HeightScale;\nfloat stepSize      = 1.0 / NUM_STEPS;\n\n// Направление смещения по UV\nfloat2 deltaUV = parallaxDir * parallaxScale * stepSize;\n\n// Начальные значения\nfloat  currLayerHeight = 0.0;\nfloat2 currUV = uv;\nfloat  currHeight = baseHeight;\n\nfloat2 prevUV = currUV;\nfloat  prevLayerHeight = 0.0;\nfloat  prevHeight = currHeight;\n\n// Поиск пересечения луча с высотным полем\n[loop]\nfor (int i = 0; i < NUM_STEPS; ++i)\n{\n    prevUV           = currUV;\n    prevLayerHeight  = currLayerHeight;\n    prevHeight       = currHeight;\n\n    currLayerHeight += stepSize;\n    currUV          -= deltaUV;  // идём \"в глубину\"\n    currHeight       = HeightTex.Sample(HeightTexSampler, currUV).r;\n\n    // когда высота карты стала ниже высоты слоя — мы \"зашли под поверхность\"\n    if (currHeight < currLayerHeight)\n    {\n        break;\n    }\n}\n\n// Дополнительное уточнение между prevUV и currUV\nfloat2 refinedUV = currUV;\nfloat  refinedLayerHeight = currLayerHeight;\n\nfloat2 dirRefine = (currUV - prevUV) / max((float)REFINE_STEPS, 1.0);\nfloat  hStepRef  = (currLayerHeight - prevLayerHeight) / max((float)REFINE_STEPS, 1.0);\n\nfloat2 testUV = prevUV;\nfloat  testLayer = prevLayerHeight;\nfloat  testHeight = prevHeight;\n\n[loop]\nfor (int j = 0; j < REFINE_STEPS; ++j)\n{\n    testUV    += dirRefine;\n    testLayer += hStepRef;\n    testHeight = HeightTex.Sample(HeightTexSampler, testUV).r;\n\n    if (testHeight < testLayer)\n    {\n        refinedUV = testUV;\n        refinedLayerHeight = testLayer;\n        break;\n    }\n}\n\n// Итоговые UV и \"глубина\" пересечения\nfloat2 parallaxUV = refinedUV;\nfloat  depth = saturate(refinedLayerHeight); // 0 = верх, 1 = дно\n\n// ===== Разделение на стены и дно =====\n\n// WallHeight: на какой части глубины заканчиваются стенки\nfloat wallH = saturate(WallHeight);\nwallH = max(wallH, 0.001);\n\n// Нормализованная глубина по стенке: 0 у края, 1 внизу стен\nfloat wallDepthNorm = saturate(depth / wallH);\n// Стены: от края до wallH\nfloat wallMask = saturate(1.0 - wallDepthNorm);\n\n// Дно (ядро): глубины ниже wallH\nfloat floorRegion = saturate((depth - wallH) / (1.0 - wallH + 1e-4));\n\n// ===== Текстура камня (стены) =====\nfloat2 rockUV = parallaxUV * RockTiling;\nfloat3 rockSample = RockTex.Sample(RockTexSampler, rockUV).rgb;\nfloat3 rockColor  = rockSample * RockTintColor;\n\n// Затемнение стен к низу\nfloat depthDark = saturate(DepthDarkness);\nfloat wallShade = lerp(1.0, 1.0 - depthDark, wallDepthNorm);\n\n// Итоговый цвет стен\nfloat3 wallColor = rockColor * wallShade * wallMask;\n\n// ===== Свечение дна и свет по стенам снизу вверх =====\n\n// Свечение на дне: 0 у начала дна, 1 в самой глубине\nfloat safeGlowPower = max(GlowPower, 0.0001);\nfloat glowGradFloor = pow(floorRegion, safeGlowPower);\n\n// Немного шума из B-канала (если есть)\nfloat glowNoise   = baseSample.b;\nfloat glowNoiseFactor = lerp(0.7, 1.0, glowNoise);\n\n// Свечение дна\nfloat glowFloorFactor = glowGradFloor * glowNoiseFactor;\nfloat3 glowFloorColor = GlowColor * GlowIntensity * glowFloorFactor;\n\n// Свечение по стенам: растёт от верха к низу (но слабее, чем на дне)\nfloat glowGradWalls = pow(depth, safeGlowPower);\nfloat wallGlowScale = 0.5; // насколько сильно подсвечиваются стены\nfloat3 glowWallColor = GlowColor * GlowIntensity * wallGlowScale * glowGradWalls * wallMask;\n\n// ===== Комбинируем стены + свечение =====\nfloat3 innerColor = wallColor + glowFloorColor + glowWallColor;\n\n// ===== Мягкий край по исходной маске (Feather) =====\nfloat edgeDenom = max(1.0 - EdgeFeather, 0.0001);\nfloat edgeMask  = saturate((baseHeight - EdgeFeather) / edgeDenom);\n\n// Итоговая непрозрачность\nfloat opacity = edgeMask * OverallOpacity;\nopacity = saturate(opacity);\n\n// Гасим цвет по opacity, чтобы край выглядел мягко\nfloat3 finalColor = innerColor * opacity;\n\n// Возвращаем RGBA\nreturn float4(finalColor, opacity);"
    },
    {
    "id": "hlsl_1770400234231",
    "title": "Diamond Progress (Diamond Shape)",
    "desc": "Процедурный шейдер ромба с настраиваемой полосой прогресса.",
    "lang": "hlsl",
    "code": "// --------------------\n// UV в -1..1\nfloat2 p = (UV - 0.5) * 2.0;\n\n// Масштаб ромба\nfloat scale = max(OuterScale, 0.0001);\np /= scale;\n\n// Ромб: |x| + |y|\nfloat d = abs(p.x) + abs(p.y);\n\n// --------------------\n// Мягкость формы\nfloat sf = max(ShapeFeather, 0.000001);\n\n// ВНЕШНИЙ край — ВСЕГДА размываем\nfloat outerMask = 1.0 - smoothstep(1.0, 1.0 + sf, d);\n\n// --------------------\n// ВНУТРЕННИЙ вырез\nfloat inner = saturate(InnerCut);\n\n// Если inner > 0 — применяем feather\nfloat innerMaskSmooth = smoothstep(inner, inner + sf, d);\n\n// Флаг наличия дырки\nfloat hasInner = step(0.00001, inner);\n\n// ❗ КЛЮЧЕВАЯ ЛОГИКА ❗\n// Нет InnerCut → innerMask = 1\nfloat innerMask = lerp(1.0, innerMaskSmooth, hasInner);\n\n// Итоговая форма\nfloat shapeMask = saturate(outerMask * innerMask);\n\n// --------------------\n// Левая / правая сторона\nfloat side = step(0.0, p.x); // 0 = левая, 1 = правая\nfloat sideMul = lerp(LeftBrightness, RightBrightness, side);\n\n// Базовый цвет\nfloat3 baseCol = BaseColor * sideMul;\n\n// --------------------\n// Прогресс\nfloat prog = saturate(Progress);\n\n// Направление через УГОЛ\nfloat ang = ProgressAngle;\nfloat2 dir = float2(cos(ang), sin(ang));\n\n// Проекция точки на направление\nfloat proj = dot(p, dir);\n\n// В 0..1\nfloat proj01 = saturate(proj * 0.5 + 0.5);\n\n// Мягкость прогресса\nfloat pf = max(ProgressFeather, 0.000001);\n\n// Маска прогресса\nfloat progMask = smoothstep(prog - pf, prog, proj01);\n\n// Цвет прогресса (с той же логикой сторон)\nfloat3 fillCol = FillColor * sideMul;\n\n// Смешивание\nfloat3 color = lerp(baseCol, fillCol, progMask);\n\n// Применяем форму\ncolor *= shapeMask;\n\n// Альфа — форма ромба\nfloat alpha = shapeMask;\n\nreturn float4(color, alpha);\n",
    "inputs": "UV, OuterScale, ShapeFeather, InnerCut, LeftBrightness, RightBrightness, BaseColor, Progress, ProgressAngle, ProgressFeather, FillColor"
}
    ,{
    "id": "hlsl_1770400405388",
    "title": "Diamond Radial Progress",
    "desc": "Процедурный ромб с круговой (радиальной) шкалой заполнения.",
    "lang": "hlsl",
    "code": "// --------------------\n// UV в -1..1\nfloat2 p = (UV - 0.5) * 2.0;\n\n// Масштаб ромба\nfloat scale = max(OuterScale, 0.0001);\np /= scale;\n\n// Ромб: |x| + |y|\nfloat d = abs(p.x) + abs(p.y);\n\n// --------------------\n// Мягкость формы\nfloat sf = max(ShapeFeather, 0.000001);\n\n// Внешний край — всегда мягкий\nfloat outerMask = 1.0 - smoothstep(1.0, 1.0 + sf, d);\n\n// --------------------\n// Внутренний вырез\nfloat inner = saturate(InnerCut);\n\n// Мягкость внутреннего края — ТОЛЬКО если есть вырез\nfloat innerMaskSmooth = smoothstep(inner, inner + sf, d);\nfloat hasInner = step(0.00001, inner);\nfloat innerMask = lerp(1.0, innerMaskSmooth, hasInner);\n\n// Итоговая форма ромба\nfloat shapeMask = saturate(outerMask * innerMask);\n\n// --------------------\n// Левая / правая сторона\nfloat side = step(0.0, p.x); // 0 = левая, 1 = правая\nfloat sideMul = lerp(LeftBrightness, RightBrightness, side);\n\n// Базовый цвет\nfloat3 baseCol = BaseColor * sideMul;\n\n// --------------------\n// РАДИАЛЬНЫЙ ПРОГРЕСС\nfloat prog = saturate(Progress);\n\n// Угол точки\nfloat ang = atan2(p.y, p.x);\n\n// Приводим к 0..1\nfloat a01 = ang * (1.0 / 6.28318530718) + 0.5;\n\n// Сдвиг старта прогресса\nfloat start = ProgressAngle * (1.0 / 6.28318530718);\nfloat angProg = frac(a01 - start);\n\n// Мягкость края прогресса\nfloat pf = max(ProgressFeather, 0.000001);\n\n// Маска прогресса (по часовой)\nfloat progMask = smoothstep(prog - pf, prog, angProg);\n\n// Цвет прогресса с той же логикой сторон\nfloat3 fillCol = FillColor * sideMul;\n\n// Смешивание\nfloat3 color = lerp(baseCol, fillCol, progMask);\n\n// Применяем форму\ncolor *= shapeMask;\n\n// Альфа — форма ромба\nfloat alpha = shapeMask;\n\nreturn float4(color, alpha);\n",
    "inputs": "UV, OuterScale, ShapeFeather, InnerCut, LeftBrightness, RightBrightness, BaseColor, Progress, ProgressAngle, ProgressFeather, FillColor"
}
,{
    "id": "hlsl_1770411883217",
    "title": "Шейдер радиального индикатора",
    "desc": "Код генерирует маску кольца с настраиваемой мягкостью краев и заполняет его цветом по часовой стрелке, начиная с верхней точки, в зависимости от значения переменной Progress.",
    "lang": "hlsl",
    "code": "float2 p = UV - 0.5;\nfloat r = length(p);\n\n// Радиусы\nfloat outerR = 0.5 - OuterEdgeInset;\nfloat innerR = InnerHoleRadius;\n\n// Защита от мусора\nouterR = max(outerR, 0.0001);\ninnerR = clamp(innerR, 0.0, outerR - 0.0001);\n\n// Мягкость\nfloat f = max(Feather, 0.000001);\n\n// Маска кольца (внутри кольца = 1)\nfloat outerMask = 1.0 - smoothstep(outerR, outerR + f, r);\nfloat innerMask = smoothstep(innerR, innerR + f, r);\nfloat ringMask  = saturate(outerMask * innerMask);\n\n// Угол: старт сверху, по часовой\nfloat ang = atan2(p.y, p.x);\nfloat a01 = ang * (1.0 / 6.28318530718) + 0.5;\na01 = frac(0.75 - a01);\n\n// Маска прогресса\nfloat prog = saturate(Progress);\nfloat progMask = step(a01, prog);\n\n// Цвет внутри кольца: база или прогресс\nfloat3 ringColor = lerp(BaseColor, ProgressColor, progMask);\n\n// ВНЕ кольца — прозрачное (вырезано)\nfloat3 rgb = ringColor * ringMask;\nfloat  a   = ringMask;\n\nreturn float4(rgb, a);\n",
    "inputs": "UV, OuterEdgeInset, InnerHoleRadius, Feather, Progress, BaseColor, ProgressColor"
}
,{
    "id": "hlsl_1770411992317",
    "title": "Dashed Rectangle Border",
    "desc": "Код отрисовывает прямоугольную рамку с настраиваемым отступом (Padding) и толщиной (Thickness), используя математику периметра для создания равномерного пунктирного паттерна по всему контуру.",
    "lang": "hlsl",
    "code": "// --- Parameters ---\nfloat2 uv = UV;\nfloat3 col = LineColor;\n\nfloat pad = saturate(Padding);\nfloat th  = max(Thickness, 1e-6);\nfloat freq = max(DashFrequency, 0.0);\n\n// --- Inner rect (padded) ---\nfloat2 mn = float2(pad, pad);\nfloat2 mx = float2(1.0 - pad, 1.0 - pad);\n\n// Width/Height of the inner rect\nfloat w = max(mx.x - mn.x, 1e-6);\nfloat h = max(mx.y - mn.y, 1e-6);\nfloat perim = 2.0 * (w + h);\n\n// --- Check if inside the inner rect ---\nfloat inside =\n    step(mn.x, uv.x) * step(uv.x, mx.x) *\n    step(mn.y, uv.y) * step(uv.y, mx.y);\n\n// --- Distances to each edge (inside rect space) ---\nfloat dL = uv.x - mn.x;\nfloat dR = mx.x - uv.x;\nfloat dB = uv.y - mn.y;\nfloat dT = mx.y - uv.y;\n\n// --- Border mask: within thickness of any edge ---\nfloat nearL = step(dL, th);\nfloat nearR = step(dR, th);\nfloat nearB = step(dB, th);\nfloat nearT = step(dT, th);\n\nfloat border = inside * saturate(nearL + nearR + nearB + nearT);\n\n// --- Decide which edge we are on (closest edge wins) ---\nfloat m = min(min(dL, dR), min(dB, dT));\n\nfloat isL = (1.0 - step(m + 1e-7, dL)) * step(dL, th);\nfloat isR = (1.0 - step(m + 1e-7, dR)) * step(dR, th);\nfloat isB = (1.0 - step(m + 1e-7, dB)) * step(dB, th);\nfloat isT = (1.0 - step(m + 1e-7, dT)) * step(dT, th);\n\n// If pixel is near multiple edges (corners), prefer a deterministic order\n// Bottom > Right > Top > Left (so s is stable)\nfloat pickB = isB;\nfloat pickR = saturate(isR * (1.0 - pickB));\nfloat pickT = saturate(isT * (1.0 - pickB) * (1.0 - pickR));\nfloat pickL = saturate(isL * (1.0 - pickB) * (1.0 - pickR) * (1.0 - pickT));\n\n// --- Compute coordinate along perimeter s (0..perim) ---\n// Order along perimeter:\n// Bottom: left->right  (0 .. w)\n// Right:  bottom->top  (w .. w+h)\n// Top:    right->left  (w+h .. 2w+h)\n// Left:   top->bottom  (2w+h .. 2w+2h)\n\nfloat tB = saturate((uv.x - mn.x) / w);          // 0..1\nfloat tR = saturate((uv.y - mn.y) / h);          // 0..1\nfloat tT = saturate((mx.x - uv.x) / w);          // 0..1 (right->left)\nfloat tL = saturate((mx.y - uv.y) / h);          // 0..1 (top->bottom)\n\nfloat sB = tB * w;\nfloat sR = w + tR * h;\nfloat sT = w + h + tT * w;\nfloat sL = w + h + w + tL * h;\n\nfloat s = pickB * sB + pickR * sR + pickT * sT + pickL * sL;\n\n// --- Dash pattern ---\n// One period = dash + gap. Here: 50% dash, 50% gap.\nfloat dashMask = 1.0;\nif (freq > 0.0)\n{\n    float phase = frac((s / perim) * freq);   // 0..1 within each period\n    dashMask = step(phase, 0.5);              // ON for first half\n}\n\n// --- Final alpha ---\nfloat a = border * dashMask;\n\n// Output RGBA: color in RGB, mask in A\nreturn float4(col, a);\n",
    "inputs": "UV, LineColor, Padding, Thickness, DashFrequency"
}
];


