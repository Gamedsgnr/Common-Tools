<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>CommonToolHub | Math Plotter Pro</title>
    <style>
        body { margin: 0; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; color: #ccc; overflow: hidden; user-select: none; }
        .sidebar { width: 380px; border-right: 2px solid #333; display: flex; flex-direction: column; background: #1e1e1e; z-index: 10; }
        
        .section-header { background: #252526; padding: 10px; font-size: 11px; font-weight: bold; color: #888; text-transform: uppercase; border-bottom: 1px solid #333; margin-top: 5px; }
        
        /* –°–µ—Ç–∫–∞ –ø—Ä–µ—Å–µ—Ç–æ–≤ */
        .presets-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; padding: 10px; background: #202020; }
        .btn-preset { background: #2d2d2d; border: 1px solid #3f3f3f; color: #d4d4d4; padding: 6px; font-size: 11px; cursor: pointer; text-align: left; border-radius: 3px; transition: 0.2s; }
        .btn-preset:hover { background: #007acc; color: white; border-color: #007acc; }

        /* –ü–∞–Ω–µ–ª—å —Ñ—É–Ω–∫—Ü–∏–π */
        .quick-fill { padding: 10px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; background: #252526; }
        .btn-func { background: #333; border: 1px solid #444; color: #4ec9b0; padding: 4px; font-size: 10px; cursor: pointer; border-radius: 2px; }
        .btn-func:hover { background: #4ec9b0; color: #111; }

        .formula-area { padding: 10px; background: #111; position: relative; }
        textarea { width: 100%; height: 70px; background: #1e1e1e; color: #ce9178; border: 1px solid #333; padding: 10px; font-family: 'Consolas', monospace; font-size: 14px; resize: none; box-sizing: border-box; outline: none; display: block; }
        textarea:focus { border-color: #007acc; }

        .error-msg { color: #f44747; font-size: 11px; padding: 5px 10px; background: rgba(244, 71, 71, 0.1); display: none; margin-top: 5px; }

        .params-container { flex: 1; overflow-y: auto; padding: 10px; display: flex; flex-direction: column; gap: 8px; border-top: 1px solid #333; }
        .param-row { display: flex; flex-direction: column; gap: 4px; font-size: 11px; background: #252526; padding: 8px; border-radius: 4px; border: 1px solid #333; }
        .param-info { display: flex; justify-content: space-between; color: #9cdcfe; font-weight: bold; }
        
        input[type="range"] { width: 100%; height: 4px; cursor: pointer; appearance: none; background: #444; border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { appearance: none; width: 12px; height: 12px; background: #007acc; border-radius: 50%; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        .output-area { padding: 10px; background: #1e1e1e; border-top: 1px solid #333; }
        .hlsl-label { font-size: 10px; color: #569cd6; margin-bottom: 5px; display: block; }
        .hlsl-code { background: #0a0a0a; padding: 10px; font-size: 12px; color: #d4d4d4; border-radius: 4px; font-family: 'Consolas', monospace; border: 1px solid #333; white-space: pre-wrap; margin-bottom: 5px; max-height: 100px; overflow-y: auto; }

        /* Main View Updates */
        .main-view { flex: 1; position: relative; background: #0c0c0c; cursor: crosshair; overflow: hidden; }
        canvas { display: block; }
        
        /* –ò–ó–ú–ï–ù–ï–ù–û: –ü–æ–¥–Ω—è–ª –∏–Ω—Ñ–æ-–ø–∞–Ω–µ–ª—å –≤—ã—à–µ, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—Ç—å —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç */
        .coord-info { position: absolute; bottom: 75px; left: 15px; background: rgba(0,0,0,0.7); padding: 5px 12px; font-size: 11px; color: #888; border-radius: 20px; border: 1px solid #333; pointer-events: none; }
        
        /* Floating Controls */
        .overlay-controls { position: absolute; top: 15px; right: 15px; display: flex; gap: 5px; }
        .btn-icon { width: 30px; height: 30px; background: #252526; border: 1px solid #444; color: #eee; border-radius: 4px; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 14px; opacity: 0.8; }
        .btn-icon:hover { opacity: 1; background: #007acc; border-color: #007acc; }

        /* –ò–ó–ú–ï–ù–ï–ù–û: –£–≤–µ–ª–∏—á–∏–ª –≤—ã—Å–æ—Ç—É —Å 25px –¥–æ 60px */
        .grad-strip { position: absolute; bottom: 0; left: 0; right: 0; height: 60px; border-top: 1px solid #333; background: #000; }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="section-header">Shader Presets</div>
    <div class="presets-grid">
        <button class="btn-preset" onclick="loadPreset('sin(x * freq + Time) * amp')">üìà Sine Wave</button>
        <button class="btn-preset" onclick="loadPreset('frac(x * freq - Time) * amp')">üìê Sawtooth</button>
        <button class="btn-preset" onclick="loadPreset('step(0.5, frac(x * freq))')">üü¶ Square Pulse</button>
        <button class="btn-preset" onclick="loadPreset('abs(frac(x * freq) * 2.0 - 1.0)')">üî∫ Triangle</button>
        <button class="btn-preset" onclick="loadPreset('smoothstep(0.0, 1.0, sin(x + Time) * 0.5 + 0.5)')">üåä Soft Glow</button>
        <button class="btn-preset" onclick="loadPreset('exp(-pow(x * freq, 2.0))')">üîã Gaussian (Exp)</button>
    </div>

    <div class="section-header">Quick HLSL functions</div>
    <div class="quick-fill">
        <button class="btn-func" onclick="insert('sin(')">sin</button>
        <button class="btn-func" onclick="insert('cos(')">cos</button>
        <button class="btn-func" onclick="insert('tan(')">tan</button>
        <button class="btn-func" onclick="insert('abs(')">abs</button>
        
        <button class="btn-func" onclick="insert('frac(')">frac</button>
        <button class="btn-func" onclick="insert('floor(')">floor</button>
        <button class="btn-func" onclick="insert('ceil(')">ceil</button>
        <button class="btn-func" onclick="insert('sign(')">sign</button>
        
        <button class="btn-func" onclick="insert('min(')">min</button>
        <button class="btn-func" onclick="insert('max(')">max</button>
        <button class="btn-func" onclick="insert('saturate(')">saturate</button>
        <button class="btn-func" onclick="insert('clamp(x, 0., 1.)')">clamp</button>
        
        <button class="btn-func" onclick="insert('lerp(a, b, t)')">lerp</button>
        <button class="btn-func" onclick="insert('step(0.5, ')">step</button>
        <button class="btn-func" onclick="insert('smoothstep(0., 1., ')">s-step</button>
        <button class="btn-func" onclick="insert('pow(x, 2.)')">pow</button>
        
        <button class="btn-func" onclick="insert('sqrt(')">sqrt</button>
        <button class="btn-func" onclick="insert('exp(')">exp</button>
        <button class="btn-func" onclick="insert('log(')">log</button>
        <button class="btn-func" onclick="insert('length(')">length</button>
    </div>

    <div class="section-header">Formula (y =)</div>
    <div class="formula-area">
        <textarea id="formulaInput" spellcheck="false" oninput="compileFormula()">sin(x * freq + Time) * amp</textarea>
        <div id="errorDisplay" class="error-msg"></div>
    </div>

    <div class="section-header">Inputs / Parameters</div>
    <div id="paramsContainer" class="params-container"></div>

    <div class="section-header">UE Custom Node (Standard)</div>
    <div class="output-area">
        <div id="hlslOutput" class="hlsl-code"></div>
        <button class="btn-preset" style="width:100%; text-align:center;" onclick="copyCode('hlslOutput')">üìã Copy for Unreal</button>
    </div>

    <div class="section-header">For HLSL Studio (Playground)</div>
    <div class="output-area">
        <div id="studioOutput" class="hlsl-code" style="color: #ce9178;"></div>
        <button class="btn-preset" style="width:100%; text-align:center; background: #28a745;" onclick="copyCode('studioOutput')">üöÄ Copy for Studio</button>
    </div>
</div>

<div class="main-view" id="mainView">
    <div class="overlay-controls">
        <button class="btn-icon" id="btnReset" title="Reset View">‚åñ</button>
        <button class="btn-icon" id="btnPlay" title="Play/Pause">‚ñ∂</button>
    </div>

    <div class="coord-info" id="coordInfo">X: 0.00, Y: 0.00</div>
    
    <canvas id="plotCanvas"></canvas>
    <canvas id="gradCanvas" class="grad-strip" height="60"></canvas>
</div>

<script>
    const canvas = document.getElementById('plotCanvas');
    const gradCanvas = document.getElementById('gradCanvas');
    const ctx = canvas.getContext('2d');
    const gCtx = gradCanvas.getContext('2d');
    
    const formulaInput = document.getElementById('formulaInput');
    const paramsContainer = document.getElementById('paramsContainer');
    const errorDisplay = document.getElementById('errorDisplay');
    const hlslOutput = document.getElementById('hlslOutput');
    const studioOutput = document.getElementById('studioOutput');
    const coordInfo = document.getElementById('coordInfo');
    const mainView = document.getElementById('mainView');
    const btnPlay = document.getElementById('btnPlay');
    const btnReset = document.getElementById('btnReset');
    
    // Logic State
    let params = { freq: 2.0, amp: 1.0, exp: 4.0 };
    let compiledFunc = null;
    let currentParamNames = []; // –î–ª—è UI (—Å–ª–∞–π–¥–µ—Ä—ã)
    let activeParamNames = [];  // –î–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ (—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫ —É—Å–ø–µ—à–Ω–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏)
    
    // View State
    let viewScale = 70; 
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let lastMouseX = 0, lastMouseY = 0;

    // Animation State
    let isPlaying = true;
    let time = 0;
    let lastFrameTime = performance.now();

    // Math Helpers
    const frac = (x) => x - Math.floor(x);
    const lerp = (a, b, t) => a * (1 - t) + b * t;
    const step = (e, x) => x < e ? 0 : 1;
    const saturate = (x) => Math.max(0, Math.min(1, x));
    const smoothstep = (e0, e1, x) => {
        let t = Math.max(0, Math.min(1, (x - e0) / (e1 - e0)));
        return t * t * (3 - 2 * t);
    };
    const clamp = (x, min, max) => Math.max(min, Math.min(max, x));

    // –°–ü–ò–°–û–ö –ú–ê–¢–ï–ú–ê–¢–ò–ß–ï–°–ö–ò–• –§–£–ù–ö–¶–ò–ô (–ø–æ—Ä—è–¥–æ–∫ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–µ–Ω)
    const MATH_FUNC_NAMES = [
        'sin', 'cos', 'abs', 'frac', 'step', 'smoothstep', 
        'lerp', 'clamp', 'saturate', 'pow', 'PI', 'floor', 'ceil',
        'exp', 'log', 'sqrt', 'tan', 'sign', 'min', 'max'
    ];

    const MATH_FUNC_REFS = [
        Math.sin, Math.cos, Math.abs, frac, step, smoothstep, 
        lerp, clamp, saturate, Math.pow, Math.PI, Math.floor, Math.ceil,
        Math.exp, Math.log, Math.sqrt, Math.tan, Math.sign, Math.min, Math.max
    ];

    function compileFormula() {
        const rawCode = formulaInput.value;
        const words = rawCode.match(/[a-zA-Z_]\w*/g) || [];
        const reserved = ['x', 'Time', ...MATH_FUNC_NAMES];
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –¥–ª—è UI
        currentParamNames = [...new Set(words.filter(w => !reserved.includes(w)))];

        try {
            // –§–æ—Ä–º–∏—Ä—É–µ–º –∞—Ä–≥—É–º–µ–Ω—Ç—ã: x, Time, [–ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è], [–º–∞—Ç. —Ñ—É–Ω–∫—Ü–∏–∏]
            const argNames = [
                'x', 'Time', 
                ...currentParamNames, 
                ...MATH_FUNC_NAMES
            ];
            
            const newFunc = new Function(...argNames, `return ${rawCode};`);
            
            // –ï—Å–ª–∏ new Function –Ω–µ —É–ø–∞–ª–∞ —Å –æ—à–∏–±–∫–æ–π, —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            compiledFunc = newFunc;
            
            // !–í–ê–ñ–ù–û: –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Å–ø–∏—Å–æ–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, –∞–∫—Ç—É–∞–ª—å–Ω—ã–π –¥–ª—è –≠–¢–û–ô –≤–µ—Ä—Å–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏
            activeParamNames = [...currentParamNames]; 
            
            errorDisplay.style.display = 'none';
            formulaInput.style.border = "1px solid #333";
            updateOutputs(rawCode);
            updateParamsUI();
        } catch (e) {
            errorDisplay.innerText = "Error: " + e.message;
            errorDisplay.style.display = 'block';
            formulaInput.style.border = "1px solid #f44747";
            // –ù–µ –æ–±–Ω—É–ª—è–µ–º compiledFunc, —á—Ç–æ–±—ã –≥—Ä–∞—Ñ–∏–∫ –Ω–µ –∏—Å—á–µ–∑–∞–ª –ø—Ä–∏ –Ω–∞–±–æ—Ä–µ —Ç–µ–∫—Å—Ç–∞
        }
    }

    function updateOutputs(code) {
        let inputs = activeParamNames.length > 0 ? `// Inputs: x, ${activeParamNames.join(', ')}\n` : `// Input: x\n`;
        hlslOutput.innerText = `${inputs}return ${code};`;

        let studioParams = activeParamNames
            .map(p => `float ${p} = ${params[p] !== undefined ? params[p].toFixed(2) : '1.0'};`)
            .join('\n');
        
        let studioBody = code.replace(/\bx\b/g, 'UV.x');
        studioOutput.innerText = `${studioParams}\n\nfloat res = ${studioBody};\nreturn float4(res, res, res, 1.0);`;
    }

    function updateParamsUI() {
        // UI —Å—Ç—Ä–æ–∏–º –Ω–∞ –±–∞–∑–µ currentParamNames (—Ç–æ, —á—Ç–æ —Å–µ–π—á–∞—Å –≤ —Ç–µ–∫—Å—Ç–µ), 
        // —á—Ç–æ–±—ã —Å–ª–∞–π–¥–µ—Ä—ã –ø–æ—è–≤–ª—è–ª–∏—Å—å —Å—Ä–∞–∑—É, –¥–∞–∂–µ –µ—Å–ª–∏ —Ñ–æ—Ä–º—É–ª–∞ –µ—â–µ –Ω–µ–≤–∞–ª–∏–¥–Ω–∞
        const existingSliders = Array.from(paramsContainer.querySelectorAll('.param-row span:first-child')).map(s => s.innerText);
        if (JSON.stringify(existingSliders.sort()) === JSON.stringify(currentParamNames.sort())) return;

        paramsContainer.innerHTML = '';
        currentParamNames.forEach(p => {
            if (params[p] === undefined) params[p] = 1.0;
            const div = document.createElement('div');
            div.className = 'param-row';
            div.innerHTML = `
                <div class="param-info"><span>${p}</span><span id="v_${p}">${params[p].toFixed(2)}</span></div>
                <input type="range" min="-5" max="5" step="0.01" value="${params[p]}" oninput="updateParamValue('${p}', this.value)">
            `;
            paramsContainer.appendChild(div);
        });
    }

    window.updateParamValue = (name, val) => {
        params[name] = parseFloat(val);
        const display = document.getElementById(`v_${name}`);
        if(display) display.innerText = params[name].toFixed(2);
        // –ù–µ –ø–µ—Ä–µ–∫–æ–º–ø–∏–ª–∏—Ä—É–µ–º –≤—Å—ë, –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç—ã –≤—ã–≤–æ–¥–∞
        if (compiledFunc) updateOutputs(formulaInput.value); 
    };

    window.insert = (text) => {
        const start = formulaInput.selectionStart;
        const end = formulaInput.selectionEnd;
        let textToInsert = text;
        let moveCursorBack = 0;

        if (text.endsWith('(') && !text.includes(')')) {
            textToInsert += ')';
            moveCursorBack = 1; 
        }

        formulaInput.value = formulaInput.value.substring(0, start) + textToInsert + formulaInput.value.substring(end);
        
        const newPos = start + textToInsert.length - moveCursorBack;
        formulaInput.setSelectionRange(newPos, newPos);
        formulaInput.focus();
        compileFormula(); // –¢—É—Ç –≤—ã–∑–æ–≤–µ—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è
    };

    window.loadPreset = (f) => {
        formulaInput.value = f;
        compileFormula();
    };

    window.copyCode = (id) => {
        navigator.clipboard.writeText(document.getElementById(id).innerText);
    };

    // --- Interaction ---
    mainView.addEventListener('mousedown', (e) => {
        if(e.target.tagName !== 'CANVAS') return;
        isDragging = true;
        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
    });

    window.addEventListener('mouseup', () => isDragging = false);

    mainView.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const worldX = (mx - canvas.width/2 - offsetX) / viewScale;
        const worldY = -(my - canvas.height/2 - offsetY) / viewScale;
        coordInfo.innerText = `X: ${worldX.toFixed(2)}, Y: ${worldY.toFixed(2)}`;

        if (isDragging) {
            offsetX += e.clientX - lastMouseX;
            offsetY += e.clientY - lastMouseY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        }
    });

    mainView.addEventListener('wheel', (e) => {
        e.preventDefault();
        const zoomSpeed = 0.1;
        const delta = e.deltaY < 0 ? 1 : -1;
        const newScale = viewScale * (1 + delta * zoomSpeed);
        viewScale = Math.max(10, Math.min(5000, newScale));
    });

    btnReset.addEventListener('click', () => {
        offsetX = 0; offsetY = 0; viewScale = 70; time = 0;
    });

    btnPlay.addEventListener('click', () => {
        isPlaying = !isPlaying;
        btnPlay.innerText = isPlaying ? "‚ùö‚ùö" : "‚ñ∂";
        if(isPlaying) lastFrameTime = performance.now();
    });

    // --- Drawing ---
    function draw() {
        requestAnimationFrame(draw);

        const now = performance.now();
        if (isPlaying) {
            time += (now - lastFrameTime) / 1000;
        }
        lastFrameTime = now;

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        const w = canvas.width, h = canvas.height;
        const cX = w / 2 + offsetX;
        const cY = h / 2 + offsetY;

        // Grid Logic
        let stepSize = 1;
        if (viewScale > 150) stepSize = 0.5;
        if (viewScale > 300) stepSize = 0.1;
        if (viewScale < 40) stepSize = 2;
        if (viewScale < 20) stepSize = 5;

        ctx.strokeStyle = '#252526';
        ctx.fillStyle = '#555';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        ctx.beginPath();

        const startX = Math.floor((-offsetX - w/2) / viewScale / stepSize) * stepSize;
        const endX = Math.ceil((-offsetX + w/2) / viewScale / stepSize) * stepSize;
        
        for(let x = startX; x <= endX; x += stepSize) {
            let val = Math.round(x*100)/100;
            let px = cX + val * viewScale;
            ctx.moveTo(px, 0); ctx.lineTo(px, h);
            if(Math.abs(val) > 0.001) ctx.fillText(val, px, cY + 12);
        }

        const startY = Math.floor((-offsetY - h/2) / viewScale / stepSize) * stepSize;
        const endY = Math.ceil((-offsetY + h/2) / viewScale / stepSize) * stepSize;

        for(let y = startY; y <= endY; y += stepSize) {
            let val = Math.round(y*100)/100;
            let py = cY - val * viewScale;
            ctx.moveTo(0, py); ctx.lineTo(w, py);
            if(Math.abs(val) > 0.001) ctx.fillText(val, cX - 12, py + 4);
        }
        ctx.stroke();

        ctx.strokeStyle = '#444';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cX, 0); ctx.lineTo(cX, h);
        ctx.moveTo(0, cY); ctx.lineTo(w, cY);
        ctx.stroke();

        if (!compiledFunc) return;

        // !–í–ê–ñ–ù–û: –°–æ–±–∏—Ä–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, –∏—Å–ø–æ–ª—å–∑—É—è activeParamNames - 
        // —Ç–æ—Ç —Å–ø–∏—Å–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –±—ã–ª –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏.
        const pValues = activeParamNames.map(n => params[n] || 0.0);
        
        ctx.strokeStyle = '#4ec9b0';
        ctx.lineWidth = 2.5;
        ctx.beginPath();

        let started = false;
        const gw = gradCanvas.width; 
        const gh = gradCanvas.height;
        const imgData = gCtx.createImageData(gw, gh);
        const data = imgData.data;

        for(let px = 0; px < w; px++) {
            const x = (px - cX) / viewScale;
            try {
                // –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏: X, Time, [USER_PARAMS], [MATH_FUNCS]
                const y = compiledFunc(x, time, ...pValues, ...MATH_FUNC_REFS);
                
                const py = cY - y * viewScale;
                
                if (!started) { ctx.moveTo(px, py); started = true; }
                else {
                    const prevX = (px - 1 - cX) / viewScale;
                    const prevYWorld = compiledFunc(prevX, time, ...pValues, ...MATH_FUNC_REFS);
                    const prevY = cY - prevYWorld * viewScale;
                    
                    if (Math.abs(py - prevY) > h) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }

                // Gradient
                const val = Math.max(0, Math.min(1, y)); 
                const col = Math.floor(val * 255);
                for(let gy = 0; gy < gh; gy++) {
                    const idx = (gy * gw + px) * 4;
                    data[idx] = col; data[idx+1] = col; data[idx+2] = col; data[idx+3] = 255;
                }

            } catch(e) {}
        }
        ctx.stroke();
        gCtx.putImageData(imgData, 0, 0);
    }

    window.onresize = () => { 
        canvas.width = mainView.clientWidth; 
        canvas.height = mainView.clientHeight;
        gradCanvas.width = mainView.clientWidth;
        gradCanvas.height = gradCanvas.clientHeight;
    };
    
    window.onresize();
    compileFormula();
    draw();
</script>
</body>
</html>