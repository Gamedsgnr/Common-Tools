<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Economy Solver Pro</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css">
    <script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1e1e1e;
            color: #d4d4d4;
            margin: 0;
            height: 100vh;
        }
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #333; border: 2px solid #1e1e1e; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }

        input, select {
            background-color: #252526 !important;
            border: 1px solid #333 !important;
            color: #ccc !important;
            outline: none;
        }
        input:focus { border-color: #007acc !important; }
        [x-cloak] { display: none !important; }

        .matrix-table input {
            width: 80px;
            padding: 4px 8px;
            font-family: 'Consolas', monospace;
            text-align: right;
        }
        .btn-blue { background-color: #007acc; color: white; transition: 0.2s; }
        .btn-blue:hover { background-color: #005a9e; }
        .card { background-color: #252526; border: 1px solid #333; }
        .tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            color: #888;
        }
        .tab.active {
            color: #4ec9b0;
            font-weight: bold;
            border-bottom-color: #4ec9b0;
        }
        .row-sum-error { background-color: #5a1d1d !important; }

        /* Drawflow styles */
        :root {
            --df-node-bg: #1f2937;
            --df-node-border: #374151;
            --df-node-text: #f3f4f6;
            --df-connection-color: #3b82f6;
            --df-connection-width: 3px;
        }
        #leontiefDrawflow {
            background-size: 25px 25px;
            background-image: radial-gradient(#374151 1px, transparent 1px);
            background-color: #111827;
            height: 100%; width: 100%;
        }
        .drawflow .drawflow-node {
            background: var(--df-node-bg);
            border: 2px solid var(--df-node-border);
            border-radius: 8px;
            min-width: 180px;
            color: var(--df-node-text);
            padding: 0;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        }
        .drawflow .drawflow-node.selected {
            background: var(--df-node-bg) !important;
            border-color: #3b82f6;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.6);
        }
        .drawflow-node-header {
             padding: 6px 10px;
             border-bottom: 1px solid #374151;
             font-weight: bold;
             font-size: 0.8rem;
             color: #93c5fd;
        }
        .drawflow-node-content {
             padding: 10px;
             font-size: 0.75rem;
             line-height: 1.5;
        }
        .drawflow-node .input, .drawflow-node .output {
            background: transparent;
            width: 0;
            height: 0;
            border-style: solid;
        }
        .drawflow-node .input {
            border-width: 8px 8px 8px 0;
            border-color: transparent #3b82f6 transparent transparent;
            left: -1px;
        }
        .drawflow-node .output {
            border-width: 8px 0 8px 8px;
            border-color: transparent transparent transparent #3b82f6;
            right: -9px;
        }

    </style>
</head>
<body x-data="matrixApp" x-init="init()">

    <div class="h-screen flex flex-col overflow-hidden">
        <header class="h-12 border-b border-[#333] bg-[#2d2d2d] flex justify-between items-center px-6 shrink-0">
            <div class="flex items-center gap-3">
                <span style="color: #4ec9b0; font-weight: bold;">ðŸ§® Matrix Optimizer</span>
                <span class="text-[10px] bg-[#3e3e42] px-2 py-0.5 rounded text-[#888]">PRO VERSION</span>
            </div>
            <div class="flex gap-2">
                <button @click="solve()" class="btn-blue px-6 py-1 rounded text-sm font-bold shadow-lg">RUN CALCULATIONS</button>
            </div>
        </header>

        <div class="flex flex-1 overflow-hidden">
            <main class="flex-1 flex flex-col overflow-auto bg-[#1e1e1e]">
                <div class="flex border-b border-[#333] shrink-0">
                    <div @click="activeTab = 'simplex'" :class="{'active': activeTab === 'simplex'}" class="tab">Simplex Optimizer</div>
                    <div @click="activeTab = 'leontief'" :class="{'active': activeTab === 'leontief'}" class="tab">Leontief I-O Analysis</div>
                    <div @click="activeTab = 'markov'" :class="{'active': activeTab === 'markov'}" class="tab">Markov Chains</div>
                </div>

                <div x-show="activeTab === 'simplex'" class="flex flex-1 overflow-hidden" x-cloak>
                    <div x-data="simplexEngine" class="w-full flex">
                        <aside class="w-72 bg-[#252526] border-r border-[#333] p-4 overflow-y-auto shrink-0">
                            <div class="mb-6">
                                <div class="flex justify-between items-center mb-2"><h3 class="text-[11px] uppercase font-bold text-[#6c6c6c]">Resources</h3><button @click="addResource()" class="text-[#4ec9b0] hover:text-white text-lg">+</button></div>
                                <div class="space-y-2"><template x-for="(res, idx) in resources" :key="idx"><div class="p-2 card rounded"><input type="text" x-model="res.name" class="w-full text-xs font-bold mb-1 bg-transparent border-none"><div class="flex justify-between items-center"><span class="text-[10px] text-[#6c6c6c]">Limit:</span><input type="number" x-model.number="res.limit" class="w-20 text-[10px] p-1 rounded"></div></div></template></div>
                            </div>
                            <div class="mb-6">
                                <div class="flex justify-between items-center mb-2"><h3 class="text-[11px] uppercase font-bold text-[#6c6c6c]">Products</h3><button @click="addProduct()" class="text-[#4ec9b0] hover:text-white text-lg">+</button></div>
                                <div class="space-y-2"><template x-for="(prod, idx) in products" :key="idx"><div class="p-2 card rounded"><input type="text" x-model="prod.name" class="w-full text-xs font-bold mb-1 bg-transparent border-none"><div class="flex justify-between items-center"><span class="text-[10px] text-[#6c6c6c]">Profit:</span><input type="number" x-model.number="prod.profit" class="w-20 text-[10px] p-1 rounded"></div></div></template></div>
                            </div>
                        </aside>
                        <div class="flex-1 overflow-auto p-8">
                             <h2 class="text-sm font-bold mb-6 text-[#4ec9b0]">Production Coefficients (Resource per Product)</h2>
                            <div class="inline-block card rounded-lg overflow-hidden mb-10">
                                <table class="matrix-table text-xs">
                                    <thead><tr class="bg-[#2d2d2d]"><th class="p-3 border-b border-[#333]"></th><template x-for="p in products"><th class="p-3 border-b border-[#333] text-[#4ec9b0] font-normal" x-text="p.name"></th></template></tr></thead>
                                    <tbody><template x-for="(res, rIdx) in resources" :key="rIdx"><tr><td class="p-3 bg-[#2d2d2d] border-r border-[#333] font-bold" x-text="res.name"></td><template x-for="(prod, pIdx) in products" :key="pIdx"><td class="p-1 border-b border-r border-[#333]"><input type="number" step="0.1" x-model.number="matrixA[rIdx][pIdx]"></td></template></tr></template></tbody>
                                </table>
                            </div>
                            <template x-if="results"><div class="grid grid-cols-2 gap-8"><div class="card p-6 rounded-lg"><h3 class="text-[#4ec9b0] font-bold text-xs uppercase mb-4">Optimal Plan</h3><div class="space-y-2"><template x-for="(val, key) in results.solution" :key="key"><div x-show="typeof val === 'number' && key !== 'result'" class="flex justify-between border-b border-[#333] py-2"><span class="text-[#888]" x-text="key"></span><span class="text-white font-bold font-mono" x-text="val.toFixed(2)"></span></div></template></div><div class="mt-6 flex justify-between items-center"><span class="text-[10px] text-[#6c6c6c] uppercase">Expected Profit:</span><span class="text-2xl font-black text-white" x-text="results.totalProfit.toFixed(0)"></span></div></div><div class="card p-6 rounded-lg"><h3 class="text-[#ce9178] font-bold text-xs uppercase mb-4">Resource Utilization</h3><div class="space-y-4"><template x-for="(data, name) in results.usage" :key="name"><div><div class="flex justify-between text-[10px] mb-1"><span x-text="name"></span><span x-text="data.used.toFixed(1) + '/' + data.limit"></span></div><div class="w-full h-1.5 bg-[#1e1e1e] rounded-full overflow-hidden"><div class="h-full" :style="`width: ${Math.min(data.percent, 100)}%`" :class="data.percent > 90 ? 'bg-orange-600' : 'bg-[#007acc]'"></div></div></div></template></div></div></div></template>
                        </div>
                    </div>
                </div>

                <div x-show="activeTab === 'leontief'" class="flex flex-1 overflow-hidden" x-cloak>
                    <div x-data="leontiefEngine" class="w-full flex">
                        <aside class="w-96 bg-[#252526] border-r border-[#333] p-4 flex flex-col">
                             <h2 class="text-sm font-bold mb-4 text-[#4ec9b0] flex-shrink-0">Technology Matrix & Demand</h2>
                             <div class="mb-4 flex-shrink-0">
                                <div class="flex justify-between items-center mb-2">
                                    <h3 class="text-[11px] uppercase font-bold text-[#6c6c6c]">Economy Items</h3>
                                    <button @click="addItem()" class="text-[#4ec9b0] hover:text-white text-lg">+</button>
                                </div>
                                <div class="space-y-2 max-h-48 overflow-y-auto pr-2">
                                    <template x-for="(item, idx) in items" :key="idx"><div class="p-2 card rounded flex justify-between items-center"><input type="text" x-model="item.name" @change="visualizeGraph(false)" class="w-full text-xs font-bold bg-transparent border-none"><div class="flex items-center"><span class="text-[10px] text-[#6c6c6c] mr-2">Demand:</span><input type="number" x-model.number="item.demand" class="w-20 text-[10px] p-1 rounded"></div></div></template>
                                </div>
                            </div>
                            <div class="flex-grow overflow-auto pr-2">
                                <p class="text-xs text-[#888] mb-2 max-w-xl flex-shrink-0">Matrix A: How many units of 'Row' are needed for 1 unit of 'Col'.</p>
                                <div class="inline-block card rounded-lg overflow-hidden">
                                    <table class="matrix-table text-xs">
                                        <thead><tr class="bg-[#2d2d2d]"><th class="p-2 border-b border-[#333] sticky top-0 left-0 z-10 bg-[#2d2d2d] text-center">â†“/â†’</th><template x-for="item in items"><th class="p-2 border-b border-[#333] text-[#4ec9b0] font-normal sticky top-0 bg-[#2d2d2d]" x-text="item.name"></th></template></tr></thead>
                                        <tbody><template x-for="(rowItem, rIdx) in items" :key="rIdx"><tr><td class="p-2 bg-[#2d2d2d] border-r border-[#333] font-bold sticky left-0" x-text="rowItem.name"></td><template x-for="(colItem, cIdx) in items" :key="cIdx"><td class="p-1 border-b border-r border-[#333]"><input type="number" step="0.1" x-model.number="techMatrix[rIdx][cIdx]"></td></template></tr></template></tbody>
                                    </table>
                                </div>
                            </div>
                        </aside>
                         <div class="flex-1 relative">
                            <div id="leontiefDrawflow" class="h-full w-full" @drop.prevent @dragover.prevent></div>
                            <template x-if="totalProduction">
                                <div class="absolute top-4 left-4 card p-4 rounded-lg bg-black/50 backdrop-blur-sm max-w-xs max-h-[90%] overflow-y-auto">
                                     <h3 class="text-[#ce9178] font-bold text-xs uppercase mb-2">Total Production Required (X)</h3>
                                     <div class="space-y-1">
                                         <template x-for="(item, idx) in items" :key="idx"><div class="flex justify-between border-b border-[#333] py-1 text-xs"><span class="text-[#888]" x-text="item.name"></span><span class="text-white font-mono" x-text="totalProduction[idx] ? totalProduction[idx].toFixed(2) : '0.00'"></span></div></template>
                                     </div>
                                 </div>
                            </template>
                         </div>
                    </div>
                </div>
                
                <div x-show="activeTab === 'markov'" class="flex flex-1 overflow-hidden" x-cloak>
                   <div x-data="markovEngine" class="w-full flex">
                        <aside class="w-72 bg-[#252526] border-r border-[#333] p-4 overflow-y-auto shrink-0">
                             <div class="mb-6">
                                <div class="flex justify-between items-center mb-2"><h3 class="text-[11px] uppercase font-bold text-[#6c6c6c]">System States</h3><button @click="addState()" class="text-[#4ec9b0] hover:text-white text-lg">+</button></div>
                                <div class="space-y-2"><template x-for="(state, idx) in states" :key="idx"><div class="p-2 card rounded"><input type="text" x-model="state.name" class="w-full text-xs font-bold bg-transparent border-none"></div></template></div>
                            </div>
                            <div class="mb-6 card p-3">
                                <h3 class="text-[11px] uppercase font-bold text-[#6c6c6c] mb-2">Initial State Vector</h3>
                                <template x-for="(state, idx) in states" :key="idx">
                                    <div class="flex justify-between items-center mb-1"><span class="text-xs text-[#888]" x-text="state.name"></span><input type="number" step="0.01" min="0" max="1" x-model.number="initialVector[idx]" class="w-20 text-[10px] p-1 rounded"></div>
                                </template>
                            </div>
                             <div class="mb-6 card p-3">
                                <h3 class="text-[11px] uppercase font-bold text-[#6c6c6c] mb-2">Simulation Steps</h3>
                                <input type="number" min="1" x-model.number="steps" class="w-full text-sm p-1 rounded">
                            </div>
                        </aside>
                         <div class="flex-1 overflow-auto p-8">
                            <h2 class="text-sm font-bold mb-6 text-[#4ec9b0]">Transition Probability Matrix (P)</h2>
                            <p class="text-xs text-[#888] mb-4 max-w-xl">Each cell (Row, Col) is the probability of moving FROM 'Row' state TO 'Col' state. <strong class="text-[#ce9178]">Each row's sum must equal 1.</strong></p>
                            <div class="inline-block card rounded-lg overflow-hidden mb-10">
                                <table class="matrix-table text-xs">
                                    <thead><tr class="bg-[#2d2d2d]"><th class="p-3 border-b border-[#333] sticky left-0 z-10 bg-[#2d2d2d]">â†“ FROM / TO â†’</th><template x-for="state in states"><th class="p-3 border-b border-[#333] text-[#4ec9b0] font-normal" x-text="state.name"></th></template></tr></thead>
                                    <tbody><template x-for="(rowState, rIdx) in states" :key="rIdx"><tr><td class="p-3 bg-[#2d2d2d] border-r border-[#333] font-bold" x-text="rowState.name"></td><template x-for="(colState, cIdx) in states" :key="cIdx"><td class="p-1 border-b border-r border-[#333]"><input type="number" step="0.01" min="0" max="1" x-model.number="transitionMatrix[rIdx][cIdx]" :class="{'row-sum-error': rowSums[rIdx] !== 1}"></td></template></tr></template></tbody>
                                </table>
                            </div>
                            <div class="grid grid-cols-2 gap-8"><template x-if="results.after_n_steps"><div class="card p-6 rounded-lg"><h3 class="text-[#ce9178] font-bold text-xs uppercase mb-4" x-text="`Distribution after ${steps} Steps`"></h3><div class="space-y-2"><template x-for="(state, idx) in states" :key="idx"><div class="flex justify-between border-b border-[#333] py-2"><span class="text-[#888]" x-text="state.name"></span><div class="flex items-center gap-4"><span class="text-sm text-gray-400" x-text="`( ${(initialVector[idx]*100).toFixed(1)}% -> ${(results.after_n_steps[idx]*100).toFixed(1)}% )`"></span><span class="text-white font-bold font-mono text-lg" x-text="(results.after_n_steps[idx]*100).toFixed(2) + '%'"></span></div></div></template></div></div></template><template x-if="results.steady_state"><div class="card p-6 rounded-lg"><h3 class="text-[#9cdcfe] font-bold text-xs uppercase mb-4">Steady-State Distribution (Long-term)</h3><div class="space-y-2"><template x-for="(state, idx) in states" :key="idx"><div class="flex justify-between border-b border-[#333] py-2"><span class="text-[#888]" x-text="state.name"></span><span class="text-white font-bold font-mono text-lg" x-text="(results.steady_state[idx]*100).toFixed(2) + '%'"></span></div></template></div></div></template></div>
                         </div>
                    </div>
                </div>

            </main>
        </div>
    </div>
    
    <script>
        var solver=function(){"use strict";class t{constructor(t,e,s,i){this.feasible=s,this.evaluation=e,this.bounded=i,this._tableau=t,this.solutionSet={}}generateSolutionSet(){const t={},e=this._tableau,s=e.varIndexByRow,i=e.variablesPerIndex,o=e.matrix,a=e.width,n=e.rhsColumn,l=e.height-1,h=Math.round(1/e.precision);for(let e=1;e<=l;e+=1){const l=s[e],r=i[l];if(void 0===r||!0===r.isSlack)continue;const c=o[e*a+n];t[r.id]=Math.round((Number.EPSILON+c)*h)/h}return t}}class e extends t{constructor(t,e,s,i,o){super(t,e,s,i),this.iter=o}}class s{constructor(t=64){this.heap=new Array(t),this.size=0,this.seqCounter=0,this.pool=new Array(64),this.poolSize=0}allocEntry(t,e){if(this.poolSize>0){const s=this.pool[--this.poolSize];return s.branch=t,s.seq=e,s}return{branch:t,seq:e}}freeEntry(t){this.poolSize<256&&(this.pool[this.poolSize++]=t)}get length(){return this.size}isEmpty(){return 0===this.size}clear(){this.size=0,this.seqCounter=0}isBefore(t,e){return t.branch.relaxedEvaluation!==e.branch.relaxedEvaluation?t.branch.relaxedEvaluation<e.branch.relaxedEvaluation:t.seq>e.seq}push(t){const e=this.heap;let s=this.size;if(this.size++,s>=e.length&&(e.length=2*e.length),t=this.allocEntry(t,this.seqCounter++),s>0){let o=(s-1)>>1;for(;s>0&&this.isBefore(t,e[o]);)e[s]=e[o],s=o,o=(s-1)>>1}e[s]=t}pop(){if(0===this.size)return;const t=this.heap,e=t[0],i=e.branch;if(this.size--,this.freeEntry(e),0===this.size)return i;const o=t[this.size];let a=0;const n=this.size>>1;for(;a<n;){let e=(a<<1)+1,s=t[e];const i=e+1;if(i<this.size&&this.isBefore(t[i],s)&&(e=i,s=t[i]),!this.isBefore(s,o))break;t[a]=s,a=e}return t[a]=o,i}peek(){return this.size>0?this.heap[0].branch:void 0}}function i(t,e,s){return{type:t,varIndex:e,value:s}}function o(t,e){return{relaxedEvaluation:t,cuts:e}}function a(){const t=(t,e)=>{var s;t.restore(),t.addCutConstraints(e),t.simplex(),(null===(s=t.model)||void 0===s?void 0:s.useMIRCuts)&&(()=>{let e=.9*t.computeFractionalVolume(!0);for(;t.applyMIRCuts(),t.simplex(),t.computeFractionalVolume(!0)<e;)e=.9*t.computeFractionalVolume(!0)})()},n=(n)=>{var l,h,r,c,d;const u=new s;let p=0;const m=null!==(h=(null===(l=n.model)||void 0===l?void 0:l.tolerance)&&void 0!==h?h:0);let v=!0,g=1e99;(null===(r=n.model)||void 0===r?void 0:r.timeout)&&(g=Date.now()+n.model.timeout);let b=-1/0,f=null;const w=[],y=n.optionalObjectives,S=y.length;for(let t=0;t<S;t+=1)w.push(1/0);const I=o(-1/0,[]);let x;for(u.push(I);!u.isEmpty()&&!0===v&&Date.now()<g;){if(null===(c=n.model)||void 0===c?void 0:c.isMinimization?x=n.bestPossibleEval*(1+m):x=n.bestPossibleEval*(1-m),m>0&&b<x&&(v=!1),I=u.pop(),I.relaxedEvaluation>=b)continue;const l=I.cuts;if(t(n,l),p++,!1===n.feasible)continue;const s=n.evaluation;if(s>b)continue;if(s===b){let t=!0;for(let e=0;e<S;e+=1){const s=y[e].reducedCosts[0],i=w[e];if(s>i)break;if(s<i){t=!1;break}}if(t)continue}if(!0===n.isIntegral()){if(n.__isIntegral=!0,1===p)return void(n.branchAndCutIterations=p);f=I,b=s;for(let t=0;t<S;t+=1)w[t]=y[t].reducedCosts[0];if(null===(d=n.model)||void 0===d?void 0:d.keep_solutions){const t=n.model.tableau.getSolution(),e=t.generateSolutionSet();e.result=t.evaluation,n.model.solutions||(n.model.solutions=[]),n.model.solutions.push(e)}}else{1===p&&n.save();const t=n.getMostFractionalVar(),e=t.index,s=t.value,l=[],h=[];const r=I.cuts.length;for(let t=0;t<r;t+=1){const s=I.cuts[t];s.varIndex===e?"min"===s.type?l.push(s):h.push(s):(h.push(s),l.push(s))}const c=i("min",e,Math.ceil(s));h.push(c);const d=i("max",e,Math.floor(s));l.push(d),u.push(o(s,h)),u.push(o(s,l))}}null!==f&&t(n,f.cuts),n.branchAndCutIterations=p};return{applyCuts:t,branchAndCut:n}}()=>{"use strict";return t.prototype.simplex=function(){return this.bounded=!0,this.phase1(),!0===this.feasible&&this.phase2(),this},t.prototype.dualSimplex=function(){const t=this.matrix,e=this.width,s=this.rhsColumn,i=e-1,o=this.height-1,a=this.precision,n=-a;let l=0;const h=1e4;for(;l<h;){let h=0,r=-a;for(let e=1;e<=o;e++){const s=t[e*width+rhsColumn];s<r&&(r=s,h=e)}if(0===h)return this.feasible=!0,this.setEvaluation(),l;let c=0,d=1/0;const u=h*e;for(let o=1;o<=i;o++){const i=t[u+o];if(i<n){const e=t[o];e>=n&&((e/-i)<d&&(d=e/-i,c=o))}}if(0===c)return this.feasible=!1,-1;this.pivot(h,c),l++}return this.feasible=!1,l},t.prototype.phase1=function(){const t=this.model.checkForCycles,e=t?new s:null,i=this.matrix,o=this.width,a=this.rhsColumn,n=this.width-1,l=this.height-1,h=this.precision,r=-h,c=this.unrestrictedVars,d=this.varIndexByRow,u=this.varIndexByCol;let p=0;const m=10,v=Math.max(l,n);let g=!1,b=-1/0,f=null,w=null,y=null,S=null,I=null;for(;;){let s=0,t=r;for(let e=1;e<=l;e++){if(!0===c[d[e]])continue;const s=i[e*o+a];s<t&&(t=s,s=e)}if(0===s)return this.feasible=!0,p;if(!g&&p>0&&t<=b){if(p>=m&&null===f&&(f=i.slice(),w=d.slice(),y=u.slice(),S=this.rowByVarIndex.slice(),I=this.colByVarIndex.slice()),p>=v){if(g=!0,f){i.set(f);for(let t=0;t<w.length;t++)d[t]=w[t];for(let t=0;t<y.length;t++)u[t]=y[t];for(let t=0;t<S.length;t++)this.rowByVarIndex[t]=S[t];for(let t=0;t<I.length;t++)this.colByVarIndex[t]=I[t];p=0;continue}}}0===p&&(b=t);let l=0;const m=s*o;if(g){for(let t=1;t<=n;t++){if(i[m+t]<r){l=t;break}}if(0===l)for(let t=1;t<=n;t++){const e=i[m+t];if(!0===c[u[t]]&&(e<r||e>h)){l=t;break}}}else{let t=-1/0;for(let e=1;e<=n;e++){const s=i[m+e];s<r&&-i[e]/s>t&&(t=-i[e]/s,l=e)}if(0===l)for(let t=1;t<=n;t++){const e=i[m+t];if(!0===c[u[t]]&&(e<r||e>h)){l=t;break}}}if(0===l)return this.feasible=!1,p;if(e){const t=e.add(d[s],u[l]);if(t.length>0)return this.model.messages.push("Cycle in phase 1"),this.model.messages.push("Start :"+t[0]),this.model.messages.push("Length :"+t[1]),this.feasible=!1,p}this.pivot(s,l),p+=1}},t.prototype.phase2=function(){const t=this.model.checkForCycles,e=t?new s:null,i=this.matrix,o=this.width,a=this.rhsColumn,n=this.width-1,l=this.height-1,h=this.precision,r=-h,c=this.optionalObjectives.length;let d=null;const u=this.unrestrictedVars,p=this.varIndexByCol,m=this.varIndexByRow;let v=0;let g,b;let f=!1;const w=100,y=5;let S=i[a],I=0;let x=0,C=0;const A=n,B=this.pricingBatchSize>0?this.pricingBatchSize:Math.min(500,Math.max(50,Math.floor(Math.sqrt(A)))),E=A>2*B;for(;;){if(c>0&&(d=[]),!f&&v>0&&v%w==0){const t=i[a];Math.abs(t-S)/Math.max(1,Math.abs(S))<1e-10?(I++,I>=y&&(f=!0,x=v,C=t)):I=0,S=t}if(f&&v-x>l){if(Math.abs(i[a]-C)/Math.max(1,Math.abs(C))<1e-10)return this.setEvaluation(),this.simplexIters+=1,v;x=v,C=i[a]}let t=0,s=h,w=!1;if(f)for(let t=1;t<=n;t++){if(g=i[t],(b=u[p[t]])&&g<0){s=-(t=t),w=!0;break}if(g>h){s=t=t,w=!1;break}}else if(E){const e=this.pricingBatchStart;let l=0;const r=Math.ceil(n/B);for(;0===t&&l<r;){const r=this.pricingBatchStart,d=Math.min(r+B-1,n);for(let e=r;e<=d;e++)g=i[e],(b=u[p[e]])&&c>0&&r<g&&g<h?null==d||d.push(e):b&&g<0?(-g>s&&(s=-g,t=e,w=!0)):g>s&&(s=g,t=e,w=!1);this.pricingBatchStart=d>=n?1:d+1,l++}0!==t&&(this.pricingBatchStart=e)}else for(let t=1;t<=n;t++)g=i[t],(b=u[p[t]])&&c>0&&r<g&&g<h?null==d||d.push(t):b&&g<0?(-g>s&&(s=-g,t=t,w=!0)):g>s&&(s=g,t=t,w=!1);if(c>0){let e=0;for(;0===t&&d&&d.length>0&&e<c;){const c=d,o=[];b=this.optionalObjectives[e].reducedCosts,s=h;for(let e=0;e<c.length;e++){const a=c[e];if(g=b[a],(b=u[p[a]])&&r<g&&g<h)o.push(a);else if(b&&g<0){if(-g>s){s=-g,t=a,w=!0}}else if(g>s){s=g,t=a,w=!1}}d=o,e+=1}}if(0===t)return this.setEvaluation(),this.simplexIters+=1,v;let y=0,S=1/0;for(let t=1;t<=l;t++){const e=t*o,s=i[e+a],n=i[e+t];if(!(n<r||n>h)&&(n>0&&h>s&&s>r?S=y=0:((n=w?-s/n:s/n)>h&&S>n&&(S=n,y=t)),0===y))break}if(S===1/0)return this.evaluation=-1/0,this.bounded=!1,this.unboundedVarIndex=p[t],v;if(e){const s=e.add(m[y],p[t]);if(s.length>0)return this.model.messages.push("Cycle in phase 2"),this.model.messages.push("Start :"+s[0]),this.model.messages.push("Length :"+s[1]),this.feasible=!1,v}this.pivot(y,t),v+=1}}let n=new Int32Array(1024),l=new Float64Array(1024);function h(t,e){const s=this.matrix,i=this.width;if(i>n.length&&(n=new Int32Array(2*i),l=new Float64Array(2*i)),t=t*i,e=s[t+e],i=1/e,o=this.height,a=this.varIndexByRow[t/this.width],h=this.varIndexByCol[e],this.varIndexByRow[t/this.width]=h,this.varIndexByCol[e]=a,this.rowByVarIndex[h]=t/this.width,this.rowByVarIndex[a]=-1,this.colByVarIndex[h]=-1,this.colByVarIndex[a]=e,a=0,h=0;h<this.width;h++){const e=t+h,i=s[e];-1e-16>i||i>1e-16?(i/=quotient,s[e]=i,n[a]=h,l[a]=i,a++):s[e]=0}for(s[t+e]=i,h=0;h<o;h++)if(h!==t/this.width){const i=h*this.width,o=s[i+e];if(!(-1e-16>o||o>1e-16)){if(0!==o)s[i+e]=0;continue}const r=o;if(!(-1e-16>r||r>1e-16)){for(let t=0;t<a;t++){const e=n[t],o=l[t];-1e-16>o||o>1e-16?s[i+e]-=r*o:0!==o&&(s[t+e]=0)}s[i+e]=-r/e}}}const r=this.optionalObjectives,c=r.length;if(c>0)for(let t=0;t<c;t++){const o=r[t].reducedCosts,c=o[e];if(0!==c){for(let t=0;t<a;t++){const e=n[t];o[e]-=c*l[t]}o[e]=-c*i}}}function c(t){for(let e=0;e<t.length-1;e++)for(let s=e+1;s<t.length;s++){const i=t[e],o=t[s];if(i[0]===o[0]&&i[1]===o[1]){if(s-e>t.length-s)break;let a=!0;for(let n=1;n<s-e;n++){const e=t[e+n],s=t[s+n];if(e[0]!==s[0]||e[1]!==s[1]){a=!1;break}}if(a)return[e,s-e]}}return[]}var d,u,p;t.prototype.pivot=h,t.prototype.checkForCycles=c,p={};class m{constructor(t,e,s,i){this.id=t,this.cost=e,this.index=s,this.value=0,this.priority=i}}class v extends m{constructor(t,e,s,i){super(t,e,s,i),this.isInteger=!0}}class g extends m{constructor(t,s){super(t,0,s,0),this.isSlack=!0}}class b{constructor(t,e){this.variable=t,this.coefficient=e}}function f(t,e,s){if(0===s||"required"===s)return null;const i=void 0===e?1:e,o=void 0===s?1:s;return t.addVariable(!1===t.isMinimization?-i:i,"r"+t.relaxationIndex++,!1,!1,o)}class w{constructor(t,e,s,i){this.slack=new g("s"+s,s),this.index=s,this.model=i,this.rhs=t,this.isUpperBound=e,this.terms=[],this.termsByVarIndex={},this.relaxation=null}addTerm(t,e){const s=e.index,i=this.termsByVarIndex[s];return void 0===i?(i=new b(e,t),this.termsByVarIndex[s]=i,this.terms.push(i),t=!0===this.isUpperBound?-t:t,this.model.updateConstraintCoefficient(this,e,t)):this.setVariableCoefficient(i.coefficient+t,e),this}removeTerm(t){return this}setRightHandSide(t){if(t!==this.rhs){let e=t-this.rhs;!0===this.isUpperBound&&(e=-e),this.rhs=t,this.model.updateRightHandSide(this,e)}return this}setVariableCoefficient(t,e){const s=e.index;if(-1===s)return;const i=this.termsByVarIndex[s];if(void 0===i)this.addTerm(t,e);else if(t!==i.coefficient){let s=t-i.coefficient;!0===this.isUpperBound&&(s=-s),i.coefficient=t,this.model.updateConstraintCoefficient(this,e,s)}return this}relax(t,e){this.relaxation=f(this.model,t,e),this._relax(this.relaxation)}_relax(t){null!==t&&(-1===this.isUpperBound?this.setVariableCoefficient(1,t):this.setVariableCoefficient(-1,t))}}class y{constructor(t,e){this.isEquality=!0,this.upperBound=t,this.lowerBound=e,this.model=t.model,this.rhs=t.rhs,this.relaxation=null}addTerm(t,e){return this.upperBound.addTerm(t,e),this.lowerBound.addTerm(t,e),this}removeTerm(t){return this.upperBound.removeTerm(t),this.lowerBound.removeTerm(t),this}setRightHandSide(t){this.upperBound.setRightHandSide(t),this.lowerBound.setRightHandSide(t),this.rhs=t}relax(t,e){this.relaxation=f(this.model,t,e),this.upperBound.relaxation=this.relaxation,this.upperBound._relax(this.relaxation),this.lowerBound.relaxation=this.relaxation,this.lowerBound._relax(this.relaxation)}}class S{constructor(t){this.value=t}}function I(t){const e=t.length,s=this.height,i=s+e,o=this.width,a=o-1;let n=this.matrix;const l=i*o;if(n.length<l){const t=Math.ceil(1.5*l);(e=new Float64Array(t)).set(n),this.matrix=n=e}this.height=i,this.nVars=this.width+this.height-2;const h=this.rhsColumn,r=this.rowByVarIndex,c=this.colByVarIndex,d=this.varIndexByRow,u=this.variablesPerIndex;for(let i=0;i<e;i++){const e=t[i],l="min"===e.type?-1:1,p=e.varIndex;let m=r[p];if(-1===m){n[(s+i)*o+h]=l*e.value;for(let t=1;t<=a;t+=1)n[(s+i)*o+t]=0;n[(s+i)*o+c[p]]=l}else{const t=m*o;m=n[t+h],n[(s+i)*o+h]=l*(e.value-m);for(let e=1;e<=a;e+=1)n[(s+i)*o+e]=-l*n[t+e]}m=this.getNewElementIndex(),d[s+i]=m,r[m]=s+i,c[m]=-1,u[m]=new g("s"+m,m),this.nVars+=1}}function x(t){if(t===this.costRowIndex)return!1;const e=this.width,s=this.matrix,i=t*e,o=this.variablesPerIndex[this.varIndexByRow[t]];if(void 0===o||!o.isInteger)return!1;const a=s[i+this.rhsColumn];if((o=a-Math.floor(a))<this.precision||o>1-this.precision)return!1;const n=this.height,l=n*e,h=n+1,r=h*e;if(s.length<r){const t=Math.ceil(1.5*r);(i=new Float64Array(t)).set(s),this.matrix=i}const c=this.matrix;this.height=h,this.nVars+=1;const d=this.getNewElementIndex();this.varIndexByRow[n]=d,this.rowByVarIndex[d]=n,this.colByVarIndex[d]=-1,this.variablesPerIndex[d]=new g("s"+d,d);const u=this.rhsColumn;c[l+u]=Math.floor(a);const p=this.variablesPerIndex,m=this.varIndexByCol,v=m.length;o=1-o;for(let t=1;t<v;t+=1){const s=p[m[t]],a=c[i+t];void 0!==s&&s.isInteger?c[l+t]=Math.floor(a)+Math.max(0,a-Math.floor(a)-fractionalPart)/o:c[l+t]=Math.min(0,a/o)}for(let t=0;t<e;t+=1)c[l+t]-=c[i+t];return!0}function C(t){if(t===this.costRowIndex)return!1;const e=this.width,s=this.matrix,i=t*e,o=this.variablesPerIndex[this.varIndexByRow[t]];if(void 0===o||!o.isInteger)return!1;const a=s[i+this.rhsColumn];if((o=a-Math.floor(a))<this.precision||o>1-this.precision)return!1;const n=this.height,l=n*e,h=n+1,r=h*e;if(s.length<r){const t=Math.ceil(1.5*r);(i=new Float64Array(t)).set(s),this.matrix=i}const c=this.matrix;this.height=h,this.nVars+=1;const d=this.getNewElementIndex();this.varIndexByRow[n]=d,this.rowByVarIndex[d]=n,this.colByVarIndex[d]=-1,this.variablesPerIndex[d]=new g("s"+d,d);const u=this.rhsColumn;c[l+u]=-o;const p=this.variablesPerIndex,m=this.varIndexByCol,v=m.length;o=1-o;for(let t=1;t<v;t+=1){const s=p[m[t]],a=c[i+t];n=a-Math.floor(a),void 0!==s&&s.isInteger?c[l+t]=n<=fractionalPart?-n:-(1-n)*fractionalPart/n:c[l+t]=a>=0?-a:a*fractionalPart/o}return!0}function A(){const t=this.height;let e=0;const s=10;for(let i=1;i<t&&e<s;i++)this.addLowerBoundMIRCut(i)&&e++}return t.prototype.addCutConstraints=I,t.prototype.addLowerBoundMIRCut=x,t.prototype.addUpperBoundMIRCut=C,t.prototype.applyMIRCuts=A,d.prototype.putInBase=function(t){const e=this.width;let s=this.rowByVarIndex[t];if(-1===s){const i=this.colByVarIndex[t];for(let t=1;t<this.height;t+=1){const o=this.matrix[t*e+i];if(o<-this.precision||this.precision<o){s=t;break}}this.pivot(s,i)}return s},d.prototype.takeOutOfBase=function(t){const e=this.width;let s=this.colByVarIndex[t];if(-1===s){const i=this.rowByVarIndex[t],o=i*e;for(let t=1;t<this.height;t+=1){const a=this.matrix[o+t];if(a<-this.precision||this.precision<a){s=t;break}}this.pivot(i,s)}return s},d.prototype.updateVariableValues=function(){const t=this.width,e=this.matrix,s=this.rhsColumn,i=this.variables.length,o=Math.round(1/this.precision);for(let a=0;a<i;a++){const i=this.variables[a],n=i.index,l=this.rowByVarIndex[n];i.value=-1===l?0:Math.round((e[l*t+s]+Number.EPSILON)*o)/o}},d.prototype.updateRightHandSide=function(t,e){const s=this.width,i=this.matrix,o=this.rhsColumn,a=this.height-1,n=this.rowByVarIndex[t.index];if(-1===n){const t=this.colByVarIndex[t.index];for(let s=0;s<=a;s+=1){const a=s*width;i[a+o]-=e*i[a+t]}const s=this.optionalObjectives.length;if(s>0)for(let o=0;o<s;o+=1){this.optionalObjectives[o].reducedCosts[o]-=e*reducedCosts[t]}}else i[n*s+o]-=e},d.prototype.updateConstraintCoefficient=function(t,e,s){if(t.index===e.index)throw new Error("[Tableau.updateConstraintCoefficient] constraint index should not be equal to variable index !");const i=this.width,o=this.matrix,a=this.putInBase(t.index),n=a*i,l=this.colByVarIndex[e.index];if(-1===l){const t=this.rowByVarIndex[e.index],e=t*i;for(let t=0;t<i;t+=1)o[n+t]+=s*o[e+t]}else o[n+l]-=s},d.prototype.updateCost=function(t,e){const s=this.width,i=this.matrix,o=t.index,a=s-1,n=this.colByVarIndex[o];if(-1===n){const o=this.rowByVarIndex[o]*s;if(0===t.priority)for(let t=0;t<=a;t+=1)i[t]+=e*i[o+t];else{t=this.objectivesByPriority[t.priority].reducedCosts;for(let s=0;s<=a;s+=1)t[s]+=e*i[o+s]}}else i[n]-=e},d.prototype.addConstraint=function(t){const e=t.isUpperBound?1:-1,s=this.height,i=this.width,o=i-1,a=s+1,n=a*i;if(this.matrix.length<n){const t=Math.ceil(1.5*n),e=new Float64Array(t);e.set(this.matrix),this.matrix=e}const l=this.matrix,h=s*i;for(let t=0;t<=o;t+=1)l[h+t]=0;l[h+this.rhsColumn]=e*t.rhs;const r=t.terms,c=r.length;for(let t=0;t<c;t++){const s=r[t],i=s.coefficient,o=s.variable.index,a=this.rowByVarIndex[o];if(-1===a)l[h+this.colByVarIndex[o]]+=e*i;else{const t=a*width;for(let s=0;s<=o;s+=1)l[h+s]-=e*i*l[t+s]}}const d=t.index;this.varIndexByRow[s]=d,this.rowByVarIndex[d]=s,this.colByVarIndex[d]=-1,this.height=a},d.prototype.removeConstraint=function(t){const e=t.index,s=this.height-1,i=this.width,o=this.matrix,a=this.putInBase(e),n=a*i,l=s*i;for(let t=0;t<i;t++){const e=o[l+t];o[l+t]=o[n+t],o[n+t]=e}this.varIndexByRow[a]=this.varIndexByRow[s],this.varIndexByRow[s]=-1,this.rowByVarIndex[e]=-1,this.availableIndexes[this.availableIndexes.length]=e,t.slack.index=-1,this.height-=1},d.prototype.addVariable=function(t){this.height-1;const e=this.width,s=e+1,i=this.height;var o=this.model.isMinimization?-t.cost:t.cost,a=t.priority;const n=this.matrix,l=new Float64Array(i*s);for(let t=0;t<i;t++){const i=t*e,o=t*s;for(let t=0;t<e;t++)l[o+t]=n[i+t]}this.matrix=l,this.width=s,a=s-1;const h=this.optionalObjectives.length;if(h>0)for(let t=0;t<h;t++)this.optionalObjectives[t].reducedCosts[a]=0;0===priority?(l[a]=o,this.colByVarIndex[t.index]=a,this.varIndexByCol[a]=t.index):(this.setOptionalObjective(priority,a,o),l[a]=0)},d.prototype.removeVariable=function(t){const e=t.index,s=this.width,i=this.matrix,o=s-1,a=this.takeOutOfBase(e),n=this.height-1;for(let t=0;t<=n;t++){const s=t*width;i[s+a]=i[s+o]}this.varIndexByCol[a]=this.varIndexByCol[o],this.rowByVarIndex[e]=-1,this.colByVarIndex[e]=-1,this.availableIndexes[this.availableIndexes.length]=e,this.width-=1},u=t.prototype.copy,d.prototype.copy=function(){const t=new this.constructor(this.precision,this.branchAndCutService);t.width=this.width,t.height=this.height,t.nVars=this.nVars,t.model=this.model,t.variables=this.variables,t.variablesPerIndex=this.variablesPerIndex,t.unrestrictedVars=this.unrestrictedVars,t.lastElementIndex=this.lastElementIndex,t.varIndexByRow=this.varIndexByRow.slice(),t.varIndexByCol=this.varIndexByCol.slice(),t.rowByVarIndex=this.rowByVarIndex.slice(),t.colByVarIndex=this.colByVarIndex.slice(),t.availableIndexes=this.availableIndexes.slice();const e=[];for(let s=0;s<this.optionalObjectives.length;s++)e[s]=this.optionalObjectives[s].copy();return t.optionalObjectives=e,t.objectivesByPriority={...this.objectivesByPriority},t.optionalObjectivePerPriority={...this.optionalObjectivePerPriority},t.matrix=new Float64Array(this.matrix),t},d.prototype.save=function(){this.savedState=this.copy()},d.prototype.restore=function(){if(null===this.savedState)return;const t=this.savedState;this.nVars=t.nVars,this.model=t.model,this.variables=t.variables,this.variablesPerIndex=t.variablesPerIndex,this.unrestrictedVars=t.unrestrictedVars,this.lastElementIndex=t.lastElementIndex,this.width=t.width,this.height=t.height,this.matrix.set(t.matrix);const e=t.varIndexByRow,s=this.height;for(let t=0;t<s;t+=1)this.varIndexByRow[t]=e[t];this.varIndexByRow.length=s;const i=t.varIndexByCol,o=this.width;for(let t=0;t<o;t+=1)this.varIndexByCol[t]=i[t];this.varIndexByCol.length=o;const a=t.rowByVarIndex,n=t.colByVarIndex;for(let t=0;t<this.nVars;t+=1)this.rowByVarIndex[t]=a[t],this.colByVarIndex[t]=n[t];if(t.optionalObjectives.length>0&&this.optionalObjectives.length>0){this.optionalObjectives=[],this.optionalObjectivePerPriority={};for(let e=0;e<t.optionalObjectives.length;e++){const s=t.optionalObjectives[e].copy();this.optionalObjectives[e]=s,this.optionalObjectivePerPriority[s.priority]=s,this.objectivesByPriority[s.priority]=s}}},d.prototype.countIntegerValues=function(){let t=0;const e=this.width,s=this.matrix,i=this.rhsColumn;for(let o=1;o<this.height;o+=1){const a=this.variablesPerIndex[this.varIndexByRow[o]];if(void 0!==a&&a.isInteger){const o=s[o*e+i];o-Math.floor(o)<this.precision&&-o<this.precision&&(t+=1)}}return t},d.prototype.isIntegral=function(){const t=this.width,e=this.matrix,s=this.rhsColumn,i=this.model.integerVariables,o=i.length,a=this.rowByVarIndex,n=this.precision;for(let l=0;l<o;l++){const o=i[l].index,h=a[o];if(-1!==h&&Math.abs(e[h*t+s]-Math.round(e[h*t+s]))>n)return!1}return!0},d.prototype.computeFractionalVolume=function(t){let e=-1;const s=this.width,i=this.matrix,o=this.rhsColumn,a=this.height,n=this.variablesPerIndex,l=this.varIndexByRow,h=this.precision;for(let r=1;r<a;r+=1){const a=n[l[r]];if(void 0!==a&&a.isInteger){const n=i[r*s+o],l=Math.abs(n);if(Math.min(l-Math.floor(l),Math.floor(l+1))<h){if(!0!==t)return 0}else-1===e?e=l:e*=l}}return-1===e?0:e},d.prototype.getMostFractionalVar=function(){let t=0,e=null,s=0;const i=this.width,o=this.matrix,a=this.rhsColumn,n=this.model.integerVariables,l=n.length,h=this.rowByVarIndex;for(let r=0;r<l;r+=1){const l=n[r].index,c=h[l];if(-1!==c){const n=o[c*i+a];(c=Math.abs(n-Math.round(n)))>t&&(t=c,e=l,s=n)}}return{index:e,value:s}},d.prototype.getFractionalVarWithLowestCost=function(){let t=1/0,e=null,s=null;const i=this.width,o=this.matrix,a=this.rhsColumn,n=this.model.integerVariables,l=n.length;for(let h=0;h<l;h++){const l=n[h],r=l.index,c=this.rowByVarIndex[r];-1!==c&&(o[c*i+a],Math.abs(val-Math.round(val))>this.precision&&l.cost<t&&(t=l.cost,e=r,s=val))}return{index:e,value:s}},d.prototype.log=function(t){if(!t)return this;console.log("****","message","****"),console.log("Nb Variables",this.width-1),console.log("Nb Constraints",this.height-1),console.log("Basic Indexes",this.varIndexByRow),console.log("Non Basic Indexes",this.varIndexByCol),console.log("Rows",this.rowByVarIndex),console.log("Cols",this.colByVarIndex);const e=5,s=this.matrix,i=this.width;let o,a,n,l,h,r,c="";const d=[" "];for(a=1;a<this.width;a+=1)o=this.varIndexByCol[a],void 0===(n=this.variablesPerIndex[o])?l="c"+o:l=n.id,h=l.length,r=" ",n="	",h>5?r+=" ":n+="	",d[a]=r,c+=n+l;console.log(c);const u=this.costRowIndex*i;let p="\t";for(j=1;j<this.width;j+=1)p+="	",p+=d[j],p+=s[u+j].toFixed(e);p+="	",p+=d[0],p+=s[u].toFixed(e),console.log(p+"	Z");for(let t=1;t<this.height;t++){const a=t*i;let n="\t";for(o=1;o<this.width;o+=1)n+="	",n+=d[o],n+=s[a+o].toFixed(e);n+="	",n+=d[0],n+=s[a].toFixed(e),o=this.varIndexByRow[t],void 0===(l=this.variablesPerIndex[o])?h="c"+o:h=l.id,console.log(n+"	"+h)}console.log("");const m=this.optionalObjectives.length;if(m>0){console.log("    Optional objectives:");for(let t=0;t<m;t++){const o=this.optionalObjectives[t].reducedCosts;let a="";for(j=1;j<this.width;j+=1)c=o[j]<0?"":" ",a+=c,a+=d[j],a+=o[j].toFixed(e);c=o[0]<0?"":" ",a+=c+d[0]+o[0].toFixed(e),console.log(a+" z"+t)}}return console.log("Feasible?",this.feasible),console.log("evaluation",this.evaluation),this},d=t;function B(t,e,s){return{priority:t,reducedCosts:s?s.slice():new Array(e).fill(0),copy:function(){return B(this.priority,this.reducedCosts.length,this.reducedCosts)}}}class E{constructor(t=1e-8,e){this.model=null,this.matrix=new Float64Array(0),this.width=0,this.height=0,this.costRowIndex=0,this.rhsColumn=0,this.variablesPerIndex=[],this.unrestrictedVars={},this.feasible=!0,this.evaluation=0,this.simplexIters=0,this.varIndexByRow=[],this.varIndexByCol=[],this.rowByVarIndex=[],this.colByVarIndex=[],this.optionalObjectives=[],this.objectivesByPriority={},this.optionalObjectivePerPriority={},this.savedState=null,this.availableIndexes=[],this.lastElementIndex=0,this.variables=[],this.nVars=0,this.bounded=!0,this.unboundedVarIndex=null,this.branchAndCutIterations=0,this.bestPossibleEval=0,this.pricingBatchStart=1,this.pricingBatchSize=0,this.precision=t,this.branchAndCutService=null!=e?e:a()}simplex(){return d.prototype.simplex.call(this),this}phase1(){return d.prototype.phase1.call(this)}phase2(){return d.prototype.phase2.call(this)}dualSimplex(){return d.prototype.dualSimplex.call(this)}pivot(t,e){d.prototype.pivot.call(this,t,e)}checkForCycles(t){return d.prototype.checkForCycles.call(this,t)}countIntegerValues(){return d.prototype.countIntegerValues.call(this)}isIntegral(){return d.prototype.isIntegral.call(this)}computeFractionalVolume(t){return d.prototype.computeFractionalVolume.call(this,t)}addCutConstraints(t){d.prototype.addCutConstraints.call(this,t)}applyMIRCuts(){d.prototype.applyMIRCuts.call(this)}addLowerBoundMIRCut(t){return d.prototype.addLowerBoundMIRCut.call(this,t)}addUpperBoundMIRCut(t){return d.prototype.addUpperBoundMIRCut.call(this,t)}getMostFractionalVar(){return d.prototype.getMostFractionalVar.call(this)}getFractionalVarWithLowestCost(){return d.prototype.getFractionalVarWithLowestCost.call(this)}putInBase(t){return d.prototype.putInBase.call(this,t)}takeOutOfBase(t){return d.prototype.takeOutOfBase.call(this,t)}updateVariableValues(){d.prototype.updateVariableValues.call(this)}updateRightHandSide(t,e){d.prototype.updateRightHandSide.call(this,t,e)}updateConstraintCoefficient(t,e,s){d.prototype.updateConstraintCoefficient.call(this,t,e,s)}updateCost(t,e){d.prototype.updateCost.call(this,t,e)}addConstraint(t){d.prototype.addConstraint.call(this,t)}removeConstraint(t){d.prototype.removeConstraint.call(this,t)}addVariable(t){d.prototype.addVariable.call(this,t)}removeVariable(t){d.prototype.removeVariable.call(this,t)}copy(){return d.prototype.copy.call(this)}save(){d.prototype.save.call(this)}restore(){d.prototype.restore.call(this)}log(t){return d.prototype.log.call(this,t),this}applyCuts(t){this.branchAndCutService.applyCuts(this,t)}branchAndCut(){this.branchAndCutService.branchAndCut(this)}solve(){var t,e;return(null!==(e=(null===(t=this.model)||void 0===t?void 0:t.getNumberOfIntegerVariables())&&void 0!==e?e:0)>0?this.branchAndCut():this.simplex(),this.updateVariableValues(),this.getSolution()}getSolution(){var s,i,o;(o=null===(s=this.model)||void 0===s?void 0:s.isMinimization?this.evaluation:-this.evaluation,s=>(null!==(i=(null===(s=this.model)||void 0===s?void 0:s.getNumberOfIntegerVariables())&&void 0!==i?i:0)>0?new e(this,o,this.feasible,this.bounded,this.branchAndCutIterations):new t(this,o,this.feasible,this.bounded))}setOptionalObjective(t,e,s){let i=this.objectivesByPriority[t];void 0===i&&(i=B(t,Math.max(this.width,e+1)),this.objectivesByPriority[t]=i,this.optionalObjectivePerPriority[t]=i,this.optionalObjectives.push(i),this.optionalObjectives.sort(((t,e)=>t.priority-e.priority))),i.reducedCosts[e]=s}initialize(t,e,s,i){this.variables=s,this.unrestrictedVars=i,this.width=t,this.height=e,this.matrix=new Float64Array(t*e),this.varIndexByRow=new Array(this.height),this.varIndexByCol=new Array(this.width),this.varIndexByRow[0]=-1,this.varIndexByCol[0]=-1,this.nVars=t+e-2,this.rowByVarIndex=new Array(this.nVars),this.colByVarIndex=new Array(this.nVars),this.lastElementIndex=this.nVars}_resetMatrix(){if(null===this.model)throw new Error("[Tableau._resetMatrix] Model not set");const t=this.matrix,e=this.width,s=this.model.variables,i=this.model.constraints,o=s.length,a=i.length;var n=!0===this.model.isMinimization?-1:1;for(let e=0;e<o;e++){const i=s[e],o=i.priority,a=n*i.cost;0===o?t[e+1]=a:this.setOptionalObjective(o,e+1,a);const l=s[e].index;this.rowByVarIndex[l]=-1,this.colByVarIndex[l]=e+1,this.varIndexByCol[e+1]=l}let l=1;for(let s=0;s<a;s++){const o=i[s],a=o.index;this.rowByVarIndex[a]=l,this.colByVarIndex[a]=-1,this.varIndexByRow[l]=a;const n=o.terms,h=n.length,r=l*e;if(l++,o.isUpperBound)for(let e=0;e<h;e++){const s=n[e];t[r+this.colByVarIndex[s.variable.index]]=s.coefficient}else for(let e=0;e<h;e++){const s=n[e];t[r+this.colByVarIndex[s.variable.index]]=-s.coefficient}t[r]=o.isUpperBound?o.rhs:-o.rhs}}setModel(t){const e=t.nVariables+1,s=t.nConstraints+1;return this.initialize(e,s,t.variables,t.unrestrictedVariables),this.model=t,this._resetMatrix(),this}getNewElementIndex(){if(this.availableIndexes.length>0)return this.availableIndexes.pop();const t=this.lastElementIndex;return this.lastElementIndex+=1,t}density(){let t=0;const e=this.matrix,s=this.width;for(let i=0;i<this.height;i++){const o=i*s;for(let t=0;t<s;t++)0!==e[o+t]&&(t+=1)}return t/(this.height*this.width)}setEvaluation(){const t=Math.round(1/this.precision),e=this.matrix[this.costRowIndex*this.width+this.rhsColumn];e=Math.round((Number.EPSILON+e)*t)/t,this.evaluation=e,0===this.simplexIters&&(this.bestPossibleEval=e)}}function O(t,e){var s,i,o,a;let n=!1;for(const l of t.constraints)if(!e.removedConstraints.has(l)&&l.isUpperBound){let t=0;for(const i of l.terms)e.fixedVariables.has(i.variable)?t+=i.coefficient*e.fixedVariables.get(i.variable):(s=null!==(s=e.tightenedBounds.get(i.variable))&&void 0!==s?s:{},o=null!==(o=s.lower)&&void 0!==o?o:0,a=null!==(a=s.upper)&&void 0!==a?a:1/0,t+=i.coefficient>0?i.coefficient*o:i.coefficient*a);const h=l.rhs-t;if(!(h<0)){for(const t of l.terms)if(!e.fixedVariables.has(t.variable)&&t.variable.isInteger&&!(t.coefficient<=0)&&(i=null!==(i=e.tightenedBounds.get(t.variable))&&void 0!==i?i:{},o=null!==(o=i.lower)&&void 0!==o?o:0,s=null!==(s=i.upper)&&void 0!==s?s:1,o>=-.5&&s<=1.5&&t.coefficient*(s-o)>h+1e-6)){const i=o+h/t.coefficient;if(i<s-1e-6){const s=null!==(a=e.tightenedBounds.get(t.variable))&&void 0!==a?a:{};(!s.upper||i<s.upper)&&(e.tightenedBounds.set(t.variable,{...s,upper:i}),e.stats.boundsTightened++,n=!0)}}}}return n}function L(t,e){var s,i,o;let a=!1;for(const n of t.constraints)if(!e.removedConstraints.has(n)){let t=0,l=0;for(const h of n.terms){const a=e.fixedVariables.get(h.variable);if(void 0!==a){t+=h.coefficient*a,l+=h.coefficient*a;continue}s=null!==(s=e.tightenedBounds.get(h.variable))&&void 0!==s?s:{},i=null!==(i=s.lower)&&void 0!==i?i:0,o=null!==(o=s.upper)&&void 0!==o?o:1/0,h.coefficient>0?(t+=h.coefficient*i,l+=h.coefficient*(o===1/0?1e10:o)):(t+=h.coefficient*(o===1/0?1e10:o),l+=h.coefficient*i)}n.isUpperBound&&l<=n.rhs+1e-6&&!e.removedConstraints.has(n)&&(e.removedConstraints.add(n),e.stats.redundantConstraints++,a=!0),!n.isUpperBound&&t>=n.rhs-1e-6&&!e.removedConstraints.has(n)&&(e.removedConstraints.add(n),e.stats.redundantConstraints++,a=!0)}return a}function k(t,e){var s,i,o,a;let n=!1;t:for(const l of e.integerIndexes){const h={};for(const r of t.constraints)if(!e.removedConstraints.has(r))for(const t of r.terms)if(t.variable.index===l){h[r.index]=t.coefficient;break}const c=null!==(s=e.tightenedBounds.get(t.variables[l]))&&void 0!==s?s:{},d=null!==(i=c.lower)&&void 0!==i?i:0,u=null!==(o=c.upper)&&void 0!==o?o:1;if(!(u-d>1.5))for(const s in h){const i=t.constraints[s],o=h[s];let r=i.rhs,c=!1;for(const t of i.terms)if(t.variable.index!==l){const s=e.fixedVariables.get(t.variable);if(void 0!==s){r-=t.coefficient*s;continue}const i=null!==(a=e.tightenedBounds.get(t.variable))&&void 0!==a?a:{};if(t.coefficient*o>0)r-=t.coefficient*i.lower;else{if(i.upper===1/0){c=!0;break}r-=t.coefficient*i.upper}}if(!c){const s=Math.floor(r/o);if(s<u){if(e.tightenedBounds.has(t.variables[l]))e.tightenedBounds.get(t.variables[l]).upper=s;else e.tightenedBounds.set(t.variables[l],{upper:s});n=!0,e.stats.boundsTightened++;continue t}}}}return n}function M(t,e){const s={stats:{boundsTightened:0,redundantConstraints:0,infeasible:!1},fixedVariables:new Map,tightenedBounds:new Map,removedConstraints:new Set};let i=!0;const o=10;for(let a=0;a<o&&i;a++)i=!1,(s.infeasible=function(t,e){var s,i,o,a;for(const n of t.constraints){if(e.removedConstraints.has(n))continue;let l=0,h=0;for(const r of n.terms){const c=e.fixedVariables.get(r.variable);if(void 0!==c){l+=r.coefficient*c,h+=r.coefficient*c;continue}s=null!==(s=e.tightenedBounds.get(r.variable))&&void 0!==s?s:{},i=null!==(i=s.lower)&&void 0!==i?i:0,o=null!==(o=s.upper)&&void 0!==o?o:1/0,r.coefficient>0?(l+=r.coefficient*i,h+=r.coefficient*(o===1/0?1e10:o)):(l+=r.coefficient*(o===1/0?1e10:o),h+=r.coefficient*i)}if(n.isUpperBound&&l>n.rhs+1e-6)return!0;if(!n.isUpperBound&&h<n.rhs-1e-6)return!0}for(const [l,h]of e.tightenedBounds)if(null!==(a=h.lower)&&void 0!==a?a:0>null!==(s=h.upper)&&void 0!==s?s:1/0)return!0;return!1}(t,s))||(O(t,s)&&(i=!0),L(t,s)&&(i=!0),k(t,s)&&(i=!0));return s}class V{constructor(t,e,s,i,o,a){this.cost=t,this.id=e,this.isInteger=s,this.isUnrestricted=i,this.priority=o,this.weight=a}}class P{constructor(t,e,s,i){this.lo=t,this.hi=e,this.free=s,this.id=i,this.priority=0,this.weight=1}}class N{constructor(t=1e-9,e=!1,s=!1,i=!1){this.tableau=new E(t,a()),this.variables=[],this.integerVariables=[],this.unrestrictedVariables={},this.nVariables=0,this.nConstraints=0,this.isMinimization=!0,this.options=e,this.precision=t,this.useMIRCuts=s,this.checkForCycles=i,this.relaxationIndex=1,this.tableau.model=this,this.name="model",this.isPresolved=!1,this.presolveResults=null}addVariable(t,e,s,i,o){const a=s?v:m;i=i||!1,o=void 0===o?0:o,t=new a(e,t,this.nVariables,o);return this.variables.push(t),s&&this.integerVariables.push(t),i&&(this.unrestrictedVariables[this.nVariables]=!0),t.index=this.nVariables,this.nVariables+=1,this.tableau.addVariable(t),t}addConstraint(t,e,s,i,o){s instanceof S&&(s=s.value);const a=new w(s,e,this.nVariables+this.nConstraints,this);for(const[e,s]of Object.entries(t))"equal"!==e&&"min"!==e&&"max"!==e&&(s=this.variables.find((t=>t.id===e)),a.addTerm(t[e],s));return this.nConstraints+=1,this.tableau.addConstraint(a),i&&a.relax(i,o),a}updateConstraint(t,e){if(null!=e.min&&null!=e.max&&e.min===e.max)return this.updateEquality(t,e.min);if(null!=e.min)if(t.isEquality){const s=t.lowerBound.rhs,i=t.upperBound;this.removeConstraint(i),this.tableau.nVars-=1,t.isEquality=!1,t.upperBound=null,this.updateLowerBound(t,e.min),t.lowerBound.rhs!==s&&this.tableau.updateRightHandSide(t.lowerBound,t.lowerBound.rhs-s)}else this.updateLowerBound(t,e.min);if(null!=e.max)if(t.isEquality){const s=t.upperBound.rhs,i=t.lowerBound;this.removeConstraint(i),this.tableau.nVars-=1,t.isEquality=!1,t.lowerBound=null,this.updateUpperBound(t,e.max),t.upperBound.rhs!==s&&this.tableau.updateRightHandSide(t.upperBound,t.upperBound.rhs-s)}else this.updateUpperBound(t,e.max)}updateLowerBound(t,e){t.isUpperBound&&t.setRightHandSide(e),t.isUpperBound=!1,t.rhs=e}updateUpperBound(t,e){!t.isUpperBound&&t.setRightHandSide(e),t.isUpperBound=!0,t.rhs=e}updateEquality(t,e){t.isEquality||(t.isEquality=!0,t.upperBound=this.addConstraint({},"max",e),t.lowerBound=this.addConstraint({},"min",e)),t.setRightHandSide(e)}removeConstraint(t){return this.tableau.removeConstraint(t),t}addEquation(t,e,s,i){e instanceof S&&(e=e.value);const o=new w(e,!0,this.nVariables+this.nConstraints,this);this.nConstraints+=1,this.tableau.addConstraint(o);const a=new w(e,!1,this.nVariables+this.nConstraints,this);this.nConstraints+=1,this.tableau.addConstraint(a);const n=new y(o,a);for(const[e,i]of Object.entries(t))"equal"!==e&&"min"!==e&&"max"!==e&&(i=this.variables.find((t=>t.id===e)),n.addTerm(t[e],i));return s&&n.relax(s,i),n}removeEquation(t){return this.tableau.removeConstraint(t.upperBound),this.tableau.removeConstraint(t.lowerBound),t}updateVariable(t,e){this.tableau.updateCost(t,e-t.cost),t.cost=e}removeVariable(t){this.tableau.removeVariable(t)}getNumberOfIntegerVariables(){return this.integerVariables.length}isChangeOfCostFree(t){if(t.priority>0)return!0;const e=this.tableau.colByVarIndex[t.index];return-1===e||0===this.tableau.matrix[e]}presolve(){if(this.isPresolved)return;const t=M(this,this.tableau);this.tableau.addCutConstraints(t.cuts),this.presolveResults=t,this.isPresolved=!0}solve(){return this.tableau.solve()}loadJson(t){const e=t.opType,s=t.optimize,i=t.constraints,o=t.variables;var a=t.integers;e&&(this.isMinimization="min"===e),a=a||{},this.options=t.options;const n={};for(const[t,e]of Object.entries(o))e[s]=e[s]||0,e.isInteger=!!a[t],n[t]=this.addVariable(e[s],t,e.isInteger,!1,e.priority?e.priority:0);for(const[t,e]of Object.entries(i)){const s={};for(const[i,o]of Object.entries(t))n[i]&&(s[n[i].id]=o);if(null!=e.equal)this.addEquation(s,e.equal);else{if(null!=e.max){const i=this.addConstraint(s,"max",e.max);null!=e.weight&&i.relax(e.weight,e.priority?e.priority:"optional")}if(null!=e.min){const i=this.addConstraint(s,"min",e.min);null!=e.weight&&i.relax(e.weight,e.priority?e.priority:"optional")}}}(this.tableau.model=this)._resetMatrix(),this}static from_json(t){const e=new N;return e.loadJson(t),e}}function R(t){return new N(t.precision,t.options,t.useMIRCuts,t.checkForCycles)}function T(t){if("object"!=typeof t)return[];const e=Object.keys(t);let s,i=e.length;const o=new Array(i);for(;i--;)s=e[i],o[i]=[s,t[s]];return o}function F(t){const e="undefined"!=typeof process&&process.env.NODE_ENV,s=(t={name:"model",isMinimization:!0,optimize:"cost",opType:"min",options:{precision:1e-9,timeout:void 0,messageLevel:0},variables:[],constraints:[],useMIRCuts:!1,checkForCycles:!0},e=>{var i;if(e||(e=JSON.parse(t)),i=e.optimize.split("."),e.opType="min",i.length>1&&(e.opType=i[0],e.optimize=i[1]),e.opType=e.opType||"min",e.isMinimization="min"===e.opType,e.options=e.options||{},e.precision=e.options.precision||1e-8,e.timeout=e.options.timeout,e.messageLevel=e.options.messageLevel,e.useMIRCuts=e.options.useMIRCuts||!1,e.checkForCycles=e.options.checkForCycles||!0,t.name=e.name,t.isMinimization=e.isMinimization,t.optimize=e.optimize,t.opType=e.opType,t.options=e.options,t.precision=e.precision,t.timeout=e.timeout,t.messageLevel=e.messageLevel,t.useMIRCuts=e.useMIRCuts,t.checkForCycles=e.checkForCycles,t.constraints=[],t.variables=[],t.nConstraints=0,t.nVariables=0,t.integerVariables=[],t.unrestrictedVariables={},t.variablesPerIndex=[],t.relaxationIndex=1,e.variables=T(e.variables),e.constraints=T(e.constraints),e.variables.forEach((s=>{const i=s[0],o=s[1],a=new(o.integer?v:m)(i,null,null,null);a.index=t.nVariables,a.cost=o[e.optimize]||0,a.priority=o.priority||0,a.isUnrestricted=!!o.unrestricted,t.nVariables++,t.variables.push(a),t.variablesPerIndex[a.index]=a,o.integer&&t.integerVariables.push(a),a.isUnrestricted&&(t.unrestrictedVariables[a.index]=!0)})),e.constraints.forEach((s=>{const i=s[0],o=s[1];null!=o.equal?(s=o.equal,o=new w(s,!0,t.nVariables+t.nConstraints,t),t.nConstraints++,s=new w(s,!1,t.nVariables+t.nConstraints,t),t.nConstraints++,o=new y(o,s),e.variables.forEach((e=>{const s=e[0];void 0!==t.constraints[i][s]&&o.addTerm(t.constraints[i][s],t.variables.find((t=>t.id===s)))}))):(null!=o.min&&(s=new w(o.min,!1,t.nVariables+t.nConstraints,t),e.variables.forEach((e=>{const i=e[0];void 0!==t.constraints[s.id][i]&&s.addTerm(t.constraints[s.id][i],t.variables.find((t=>t.id===i)))}))),null!=o.max&&(s=new w(o.max,!0,t.nVariables+t.nConstraints,s?s.index+1:t.nVariables+t.nConstraints),e.variables.forEach((e=>{const i=e[0];void 0!==t.constraints[s.id][i]&&s.addTerm(t.constraints[s.id][i],t.variables.find((t=>t.id===i)))}))))})),"production"!==e&&!s){const e="This looks like a NodeJS environment. If you are using the browser version of javascript-lp-solver, you may have some problems.";return console.warn(e),t.messages=t.messages||[],t.messages.push(e),t.tableau=new E(t.precision),t.tableau.setModel(t),t}return t.tableau=new E(t.precision),t.tableau.setModel(t),t},i={Reformat:t=>F(t),Solve:function(t,e,s,i){const o=F(t,e),a={};return o.solve(),a.feasible=o.feasible,o.feasible&&(o.updateVariableValues(),o.variables.forEach((t=>{if(!t.isSlack){const e=t.id;a[e]=t.value}})),s||(a.result=o.evaluation),i&&(a.bounded=o.bounded,a.isIntegral=o.isIntegral())),a},Model:t=>new N(t,t?t.isMIP:0,t?t.useMIRCuts:0,t?t.checkForCycles:0)};return"undefined"!=typeof window&&(window.solver=i),i}();
    </script>
    <script>
        document.addEventListener('alpine:init', () => {
            Alpine.data('matrixApp', () => ({
                activeTab: 'simplex',
                init() {
                    console.log("matrixApp init() called.");
                    if(typeof solver == 'undefined') {
                        alert("Warning: javascript-lp-solver did not load correctly. The Simplex Optimizer tab may not work. Please check your network connection or ad-blocker.");
                    }
                },
                solve() {
                    console.log("matrixApp.solve() called. Active tab:", this.activeTab);
                    const eventName = { simplex: 'solve-simplex', leontief: 'solve-leontief', markov: 'solve-markov' }[this.activeTab];
                    if(eventName) {
                        console.log(`matrixApp: Dispatching event: ${eventName}`);
                        document.dispatchEvent(new CustomEvent(eventName, { bubbles: true }));
                    } else {
                        console.warn("matrixApp: No event name for active tab:", this.activeTab);
                    }
                }
            }));
            
             Alpine.data('simplexEngine', () => ({
                resources: [{name: 'Iron', limit: 500}, {name: 'Wood', limit: 300}],
                products: [{name: 'Sword', profit: 50}, {name: 'Shield', profit: 40}],
                matrixA: [[2, 1], [1, 3]],
                results: null,
                init() { 
                    console.log("simplexEngine init() called.");
                    document.addEventListener('solve-simplex', () => {
                        console.log("simplexEngine: 'solve-simplex' event received.");
                        this.solve();
                    }); 
                },
                addResource() { this.resources.push({name: 'New Resource', limit: 100}); this.matrixA.push(new Array(this.products.length).fill(0)); },
                addProduct() { this.products.push({name: 'New Product', profit: 10}); this.matrixA.forEach(row => row.push(0)); },
                solve() {
                    console.log("simplexEngine solve() called.");
                    if (!window.solver) return alert("solver.js not loaded.");
                    try {
                        const model = { optimize: "profit", opType: "max", constraints: {}, variables: {} };
                        this.resources.forEach(res => { model.constraints[res.name] = { max: res.limit || 0 }; });
                        this.products.forEach((prod, pIdx) => {
                            const v = { profit: prod.profit || 0 };
                            this.resources.forEach((res, rIdx) => { v[res.name] = this.matrixA[rIdx][pIdx] || 0; });
                            model.variables[prod.name] = v;
                        });
                        const solution = solver.Solve(model);
                        if (!solution.feasible) {
                            console.log("simplexEngine solve() finished with infeasible solution.");
                            return alert("Infeasible solution.");
                        }
                        const usage = {};
                        this.resources.forEach((res, rIdx) => {
                            let total = 0;
                            this.products.forEach((p, pIdx) => { total += (solution[p.name] || 0) * (this.matrixA[rIdx][pIdx] || 0); });
                            usage[res.name] = { used: total, limit: res.limit, percent: (total / res.limit) * 100 };
                        });
                        this.results = { solution, totalProfit: solution.result || 0, usage };
                        console.log("simplexEngine solve() finished successfully.");
                    } catch (e) { console.error(e); alert("Math Error: " + e.message); }
                }
            }));

            Alpine.data('leontiefEngine', () => ({
                items: [{name: 'Iron Ore', demand: 0}, {name: 'Wood', demand: 0}, {name: 'Iron Sword', demand: 10}],
                techMatrix: [[0, 0, 5], [0, 0, 2], [0, 0, 0]],
                totalProduction: null,
                editor: null,
                initEditor() {
                    if (this.editor) return;
                    console.log("leontiefEngine initEditor() called.");
                    const container = document.getElementById('leontiefDrawflow');
                    this.editor = new Drawflow(container);
                    this.editor.start();

                    document.addEventListener('solve-leontief', () => {
                        console.log("leontiefEngine: 'solve-leontief' event received.");
                        this.solve();
                    }); 
                },
                addItem() { this.items.push({name: 'New Item', demand: 0}); this.techMatrix.forEach(row => row.push(0)); this.techMatrix.push(new Array(this.items.length).fill(0)); this.visualizeGraph(false); },
                visualizeGraph(recalculate = true) {
                    if (!this.editor) return;
                    console.log("leontiefEngine visualizeGraph() called.");
                    this.editor.clear();
                    
                    const nodeWidth = 200;
                    const nodeHeight = 90;
                    const nodes = {};
                    
                    const levels = this.calculateLevels();
                    const columnWidths = levels.map(level => level.length);
                    const maxNodesInColumn = Math.max(...columnWidths);

                    levels.forEach((level, levelIndex) => {
                        const x = 50 + levelIndex * (nodeWidth + 80);
                        const columnHeight = level.length * (nodeHeight + 40);
                        let y_offset = (maxNodesInColumn - level.length) * (nodeHeight + 40) / 2;

                        level.forEach((nodeIndex, i) => {
                            const item = this.items[nodeIndex];
                            const y = 50 + y_offset + i * (nodeHeight + 40);
                            const total = recalculate && this.totalProduction ? this.totalProduction[nodeIndex].toFixed(2) : '...';
                            const html = `<div class="drawflow-node-header">${item.name}</div><div class="drawflow-node-content">Demand: ${item.demand}<br>Total: ${total}</div>`;
                            nodes[nodeIndex] = this.editor.addNode('item', 1, 1, x, y, 'item-node', { name: item.name }, html);
                        });
                    });

                    this.techMatrix.forEach((row, rIdx) => {
                        row.forEach((val, cIdx) => {
                            if (val > 0) {
                                this.editor.addConnection(nodes[rIdx], nodes[cIdx], 'output_1', 'input_1');
                            }
                        });
                    });

                    console.log("leontiefEngine visualizeGraph() finished.");
                },
                calculateLevels() {
                    const n = this.items.length;
                    const adj = Array.from({length: n}, () => []);
                    const inDegree = new Array(n).fill(0);

                    this.techMatrix.forEach((row, rIdx) => {
                        row.forEach((val, cIdx) => {
                            if (val > 0) {
                                adj[rIdx].push(cIdx);
                                inDegree[cIdx]++;
                            }
                        });
                    });

                    const queue = [];
                    for (let i = 0; i < n; i++) {
                        if (inDegree[i] === 0) {
                            queue.push(i);
                        }
                    }

                    const levels = [];
                    let level = 0;
                    while(queue.length > 0) {
                        const levelSize = queue.length;
                        levels[level] = [];
                        for(let i = 0; i < levelSize; i++) {
                            const u = queue.shift();
                            levels[level].push(u);
                            for (const v of adj[u]) {
                                inDegree[v]--;
                                if (inDegree[v] === 0) {
                                    queue.push(v);
                                }
                            }
                        }
                        level++;
                    }
                    return levels;
                },
                solve() {
                    console.log("leontiefEngine solve() called.");
                    if (!window.math) return alert("math.js not loaded.");
                    try {
                        const A = math.matrix(this.techMatrix);
                        const y = math.matrix(this.items.map(i => i.demand));
                        const n = this.items.length; if (n === 0) return;
                        const I = math.identity(n);
                        const I_minus_A = math.subtract(I, A);
                        if (math.abs(math.det(I_minus_A)) < 1e-9) return alert("Matrix is singular (non-productive economy).");
                        const leontiefInverse = math.inv(I_minus_A);
                        this.totalProduction = math.multiply(leontiefInverse, y).toArray();
                        this.$nextTick(() => this.visualizeGraph(true));
                        console.log("leontiefEngine solve() finished successfully.");
                    } catch(e) { console.error(e); alert("Math Error: " + e.message); }
                }
            }));

            Alpine.data('markovEngine', () => ({
                states: [{name: 'New Player'}, {name: 'Engaged'}, {name: 'Churned'}],
                transitionMatrix: [[0.1, 0.8, 0.1], [0.05, 0.9, 0.05], [0, 0, 1]],
                initialVector: [1, 0, 0],
                steps: 10,
                results: {},
                get rowSums() { return this.transitionMatrix.map(row => math.round(math.sum(row), 3)); },
                init() { 
                    console.log("markovEngine init() called.");
                    document.addEventListener('solve-markov', () => {
                        console.log("markovEngine: 'solve-markov' event received.");
                        this.solve();
                    }); 
                },
                addState() {
                    this.states.push({name: 'New State'}); this.initialVector.push(0); this.transitionMatrix.forEach(row => row.push(0)); this.transitionMatrix.push(new Array(this.states.length).fill(0));
                },
                solve() {
                    console.log("markovEngine solve() called.");
                    if (!window.math) return alert("math.js not loaded.");
                    try {
                        if (math.abs(math.sum(this.initialVector) - 1) > 1e-9) return alert("Sum of Initial State Vector must be 1.");
                        if (this.rowSums.some(s => math.abs(s - 1) > 1e-9)) return alert("The sum of each row in the transition matrix must be 1.");
                        
                        const P = math.matrix(this.transitionMatrix);
                        const s0 = math.matrix(this.initialVector);
                        const s_n = math.multiply(s0, math.pow(P, this.steps)).toArray();

                        const eigs = math.eigs(math.transpose(P));
                        const eigenvalues = eigs.values.toArray();
                        const steadyIdx = eigenvalues.findIndex(v => math.abs(math.subtract(v, 1)) < 1e-9);

                        if (steadyIdx === -1) {
                             this.results = { after_n_steps: s_n, steady_state: null };
                             throw new Error("No steady state found. The system may not be regular or ergodic.");
                        }
                        
                        let steadyVectorRaw = math.column(eigs.vectors, steadyIdx);
                        let steadyVector = math.flatten(steadyVectorRaw.toArray());
                        const steadySum = math.sum(steadyVector);
                        steadyVector = math.multiply(steadyVector, 1 / steadySum).map(v => math.abs(v));

                        this.results = {
                            after_n_steps: s_n,
                            steady_state: steadyVector
                        };
                        console.log("markovEngine solve() finished successfully.");
                    } catch(e) { console.error(e); alert("Markov Calc Error: " + e.message); }
                }
            }));
        });
    </script>
</body>
</html>