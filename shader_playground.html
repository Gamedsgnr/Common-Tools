<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>HLSL Custom Node Studio</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a1a; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; color: #ccc; }
        .editor-panel { width: 500px; display: flex; flex-direction: column; border-right: 2px solid #333; z-index: 10; background: #1e1e1e; }
        
        .toolbar { padding: 10px; background: #252526; border-bottom: 1px solid #333; display: flex; justify-content: space-between; gap: 5px; }
        .add-input-bar { padding: 8px 10px; background: #2d2d30; border-bottom: 1px solid #111; display: flex; gap: 5px; align-items: center; }
        
        select, input[type="text"], .btn-ui { background: #333; color: white; border: 1px solid #444; padding: 5px; border-radius: 4px; font-size: 12px; }
        input[type="text"] { flex: 1; }
        .btn-ui { cursor: pointer; font-weight: bold; border: none; }
        .btn-add { background: #007acc; }
        .btn-apply { background: #28a745; padding: 5px 15px; }

        .params-header { background: #252526; padding: 5px 10px; font-size: 10px; font-weight: bold; color: #777; text-transform: uppercase; }
        .params-container { background: #202020; padding: 10px; border-bottom: 1px solid #333; max-height: 250px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px; }
        
        .param-row { display: flex; align-items: center; gap: 8px; font-size: 12px; }
        .param-label { color: #d4d4d4; font-weight: bold; width: 90px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .param-type-tag { font-size: 9px; color: #569cd6; border: 1px solid #569cd655; padding: 1px 3px; border-radius: 3px; margin-right: 5px; }
        
        input[type="range"] { flex: 1; height: 4px; cursor: pointer; }
        .num-input { width: 50px; text-align: center; background: #111; color: #4ec9b0; border: 1px solid #333; padding: 2px; }
        .vec-input-group { display: flex; gap: 2px; flex: 1; }
        .vec-input-group input { flex: 1; min-width: 0; }
        input[type="color"] { border: none; width: 25px; height: 25px; padding: 0; cursor: pointer; background: none; }

        .export-area { display: flex; gap: 1px; background: #444; padding: 1px 0; }
        .btn-export { flex: 1; background: #333; border: none; color: #aaa; padding: 10px; cursor: pointer; font-size: 10px; font-weight: 600; }
        .btn-export:hover { background: #444; color: white; }

        .code-wrapper { flex: 1; position: relative; display: flex; flex-direction: column; }
        textarea { flex: 1; background: #1e1e1e; color: #d4d4d4; border: none; padding: 15px; font-family: 'Consolas', monospace; font-size: 13px; outline: none; line-height: 1.5; resize: none; }
        
        #canvas-container { 
            flex: 1; 
            position: relative; 
            background: radial-gradient(circle at center, #080808 0%, #181818 100%);
            cursor: grab; 
        }
        #canvas-container:active { cursor: grabbing; }
        #status-bar { position: absolute; bottom: 0; left: 0; right: 0; min-height: 25px; background: #007acc; color: white; padding: 5px 10px; font-size: 12px; font-family: monospace; pointer-events: none; z-index: 10; }

        #log-panel {
            position: absolute;
            bottom: 30px;
            right: 10px;
            width: 350px;
            max-height: 150px;
            background: rgba(0,0,0,0.8);
            border: 1px solid #444;
            color: #ccc;
            font-family: monospace;
            font-size: 11px;
            padding: 5px;
            overflow-y: auto;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 2px;
            z-index: 5;
        }
        .log-msg { border-bottom: 1px solid #333; padding-bottom: 2px; }
        .log-error { color: #ff5555; }
        .log-success { color: #55ff55; }
        .log-info { color: #55aaff; }

    </style>
</head>
<body>

<div class="editor-panel">
    <div class="toolbar">
        <select id="shapeSelect" onchange="changeMesh()">
            <option value="cube">Cube</option>
            <option value="sphere">Sphere</option>
            <option value="plane">Plane</option>
        </select>
        <button class="btn-ui btn-apply" onclick="processAndCompile()">‚ñ∂ APPLY (Ctrl+S)</button>
    </div>

    <div class="add-input-bar">
        <select id="newType">
            <option value="float">float</option>
            <option value="float2">float2</option>
            <option value="float3">float3</option>
            <option value="float4">float4</option>
            <option value="Texture2D">Texture2D</option>
        </select>
        <input type="text" id="newName" placeholder="InputName">
        <button class="btn-ui btn-add" onclick="addNewInput()">+ Add</button>
    </div>

    <div class="params-header">Material Inputs</div>
    <div id="paramsContainer" class="params-container"></div>

    <div class="export-area">
        <button class="btn-export" onclick="copyUEInputs()">üìã COPY INPUTS STRING</button>
        <button class="btn-export" onclick="copyUECode()">üìã COPY HLSL CODE</button>
    </div>

    <div class="code-wrapper">
<textarea id="shaderCode" spellcheck="false">
// --- INPUTS ---
Texture2D BaseTexture;
float3 ShieldColor = float3(0.0, 0.5, 1.0);
float GridDensity = 15.0;
float PulseSpeed = 2.5;
float Distortion = 0.1;

// --- LOGIC ---
// 1. –°–æ–∑–¥–∞–µ–º –∞–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è UV (–¥–∏—Å—Ç–æ—Ä—Å–∏—è)
float2 distortedUV = UV + sin(Time * PulseSpeed + UV.y * 10.0) * Distortion;

// 2. –ß–∏—Ç–∞–µ–º —Ç–µ–∫—Å—Ç—É—Ä—É —Å –Ω–µ–±–æ–ª—å—à–∏–º —Å–º–µ—â–µ–Ω–∏–µ–º
float4 texColor = ProcessTexture(BaseTexture, distortedUV);

// 3. –°–æ–∑–¥–∞–µ–º —Å–µ—Ç–∫—É (Grid)
float2 gridUV = frac(UV * GridDensity);
float gridLine = step(0.95, gridUV.x) + step(0.95, gridUV.y);

// 4. –°–æ–∑–¥–∞–µ–º –±–µ–≥—É—â—É—é –≤–æ–ª–Ω—É —è—Ä–∫–æ—Å—Ç–∏
float wave = sin(UV.y * 5.0 - Time * PulseSpeed) * 0.5 + 0.5;

// 5. –§–∏–Ω–∞–ª—å–Ω–æ–µ —Å–º–µ—à–∏–≤–∞–Ω–∏–µ
float3 finalRGB = lerp(texColor.rgb, ShieldColor, gridLine * wave);

// –î–æ–±–∞–≤–ª—è–µ–º —Å–≤–µ—á–µ–Ω–∏–µ (Glow) –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–æ–ª–Ω—ã
finalRGB += ShieldColor * wave * 0.3;

return float4(finalRGB, 1.0);

</textarea>
    </div>
</div>

<div id="canvas-container">
    <div id="log-panel"></div>
    <div id="status-bar">Ready</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    let camera, scene, renderer, mesh, material, controls, gridHelper;
    let startTime = Date.now();
    let activeParams = {};
    let currentInputs = [];
    let lastCleanUECode = "";

    // --- HLSL COMPATIBILITY HEADER ---
    const headerGLSL = `
        precision highp float;
        #define float2 vec2
        #define float3 vec3
        #define float4 vec4
        #define lerp mix
        #define frac fract
        #define fmod mod
        #define rsqrt inversesqrt
        #define atan2(y, x) atan(y, x)
        #define saturate(x) clamp(x, 0.0, 1.0)
        #define Texture2D sampler2D
        #define ProcessTexture(t, u) texture2D(t, u)
        
        uniform float u_time;
        #define Time u_time
        #define time u_time

        #define UV vUv
        varying vec2 vUv;
    `;

    function log(msg, type='info') {
        const el = document.getElementById('log-panel');
        const d = document.createElement('div');
        d.className = `log-msg log-${type}`;
        d.textContent = `> ${msg}`;
        el.appendChild(d);
        el.scrollTop = el.scrollHeight;
        if(el.children.length > 20) el.removeChild(el.firstChild);
    }

    function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(45, (window.innerWidth - 500) / window.innerHeight, 0.1, 100);
        camera.position.set(2, 2, 4);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth - 500, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
        gridHelper.position.y = -1;
        scene.add(gridHelper);

        createMesh('cube');
        log("System initialized", "success");
        processAndCompile();

        window.addEventListener('resize', onResize);
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); processAndCompile(); }
        });
    }

    function createMesh(type) {
        if (mesh) {
            scene.remove(mesh);
            mesh.geometry.dispose();
            mesh.material.dispose();
        }

        const geo = type==='cube' ? new THREE.BoxGeometry(1.5, 1.5, 1.5) : 
                    type==='sphere' ? new THREE.SphereGeometry(1, 32, 32) : new THREE.PlaneGeometry(2, 2);
        
        material = new THREE.ShaderMaterial({
            uniforms: { u_time: { value: 0 } },
            vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
            fragmentShader: `void main(){ gl_FragColor = vec4(0,0,0,1); }`
        });

        if(type === 'plane') {
            gridHelper.rotation.x = Math.PI / 2;
            gridHelper.position.set(0, 0, -0.01);
            camera.position.set(0, 0, 3);
            controls.target.set(0, 0, 0);
        } else {
            gridHelper.rotation.x = 0;
            gridHelper.position.set(0, -1, 0);
        }

        for (let key in activeParams) {
            material.uniforms[key] = { value: activeParams[key] };
        }

        mesh = new THREE.Mesh(geo, material);
        scene.add(mesh);
    }

    function addNewInput() {
        const type = document.getElementById('newType').value;
        const name = document.getElementById('newName').value.trim();
        const editor = document.getElementById('shaderCode');
        if (!name) return;
        
        let line = "";
        if(type === 'float') line = `float ${name} = 1.0;\n`;
        else if(type === 'float2') line = `float2 ${name} = float2(0.0, 0.0);\n`;
        else if(type === 'float3') line = `float3 ${name} = float3(1.0, 1.0, 1.0);\n`;
        else if(type === 'float4') line = `float4 ${name} = float4(1.0, 1.0, 1.0, 1.0);\n`;
        else line = `Texture2D ${name};\n`;

        editor.value = line + editor.value;
        document.getElementById('newName').value = "";
        processAndCompile();
    }

    function processAndCompile() {
        let rawCode = document.getElementById('shaderCode').value;
        rawCode = rawCode.replace(/\u00A0/g, ' ');

        const lines = rawCode.split('\n');
        let glslBody = "", ueCode = "", uniformsDecl = "", foundInputs = [];

        // –†–µ–≥—É–ª—è—Ä–∫–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏–π (–∏—â–µ–º —Ç–æ–ª—å–∫–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Å –¥–µ—Ñ–æ–ª—Ç–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏)
        const reFloat = /^\s*float\s+(\w+)\s*=\s*([-\d.e]+)f?[\s;]*$/; 
        const reVec2  = /^\s*float2\s+(\w+)\s*=\s*float2\s*\(([^)]+)\)[\s;]*$/;
        const reVec3  = /^\s*float3\s+(\w+)\s*=\s*float3\s*\(([^)]+)\)[\s;]*$/;
        const reVec4  = /^\s*float4\s+(\w+)\s*=\s*float4\s*\(([^)]+)\)[\s;]*$/;
        const reTex   = /^\s*Texture2D\s+(\w+)\s*[\s;]*$/;

        lines.forEach(line => {
            let cleanLine = line.trim();
            const codePart = cleanLine.split('//')[0].trim();

            let mF = codePart.match(reFloat);
            let mV2 = codePart.match(reVec2);
            let mV3 = codePart.match(reVec3);
            let mV4 = codePart.match(reVec4);
            let mT = codePart.match(reTex);

            if (mF) {
                foundInputs.push({name: mF[1], type: 'float', val: parseFloat(mF[2])});
                uniformsDecl += `uniform float ${mF[1]};\n`;
                // –í–ê–ñ–ù–û: –ù–µ –¥–æ–±–∞–≤–ª—è–µ–º —ç—Ç—É —Å—Ç—Ä–æ–∫—É –≤ glslBody, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–∫—Ä—ã–≤–∞—Ç—å uniform!
            } 
            else if (mV2) {
                if (mV2[1] === 'UV') {
                    // –ï—Å–ª–∏ —ç—Ç–æ UV, –º—ã –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ uniform (–∏—Å–ø–æ–ª—å–∑—É–µ–º vUv –∏–∑ —Ö–µ–¥–µ—Ä–∞)
                    // –ò –º—ã –¢–ê–ö–ñ–ï –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É –≤ body, —á—Ç–æ–±—ã UV –±—Ä–∞–ª—Å—è –∏–∑ Varying, –∞ –Ω–µ –±—ã–ª –∫–æ–Ω—Å—Ç–∞–Ω—Ç–æ–π 0.5
                    log("Detected 'float2 UV'. Using mesh coordinates.", "info");
                } else {
                    const vals = mV2[2].split(',').map(v => parseFloat(v.trim()));
                    foundInputs.push({name: mV2[1], type: 'float2', val: vals});
                    uniformsDecl += `uniform vec2 ${mV2[1]};\n`;
                }
            } 
            else if (mV3) {
                const vals = mV3[2].split(',').map(v => parseFloat(v.trim()));
                foundInputs.push({name: mV3[1], type: 'float3', val: vals});
                uniformsDecl += `uniform vec3 ${mV3[1]};\n`;
            } 
            else if (mV4) {
                const vals = mV4[2].split(',').map(v => parseFloat(v.trim()));
                foundInputs.push({name: mV4[1], type: 'float4', val: vals});
                uniformsDecl += `uniform vec4 ${mV4[1]};\n`;
            } 
            else if (mT) {
                foundInputs.push({name: mT[1], type: 'Texture2D'});
                uniformsDecl += `uniform sampler2D ${mT[1]};\n`;
            } 
            else {
                // –≠—Ç–æ –ª–æ–≥–∏–∫–∞, –æ—Å—Ç–∞–≤–ª—è–µ–º –≤ —Ç–µ–ª–µ
                glslBody += line + "\n";
                ueCode += line + "\n";
            }
        });

        currentInputs = foundInputs;
        lastCleanUECode = ueCode.trim();
        updateUI(foundInputs);

        // --- –¢–†–ê–ù–°–ü–ò–õ–Ø–¶–ò–Ø ---
        let finalBody = glslBody;
        finalBody = finalBody.replace(/\b(\d+\.\d+)f\b/g, "$1");
        finalBody = finalBody.replace(/(\w+)\.Sample\s*\(\s*\w+\s*,\s*([^)]+)\)/g, "texture2D($1, $2)");
        finalBody = finalBody.replace(/\((float|int)\)\s*([a-zA-Z0-9_]+)/g, "$1($2)");
        finalBody = finalBody.replace(/return\s+([^;]+);/g, "gl_FragColor = $1; return;");

        if(mesh) {
            try {
                mesh.material.fragmentShader = headerGLSL + uniformsDecl + "void main(){\n" + finalBody + "\n}";
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ uniforms (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏—Ö –µ—â–µ –Ω–µ—Ç –∏–ª–∏ —Ç–∏–ø –ø–æ–º–µ–Ω—è–ª—Å—è)
                // –ú—ã –Ω–µ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è, –µ—Å–ª–∏ –∏–º—è —Å–æ–≤–ø–∞–¥–∞–µ—Ç
                foundInputs.forEach(p => {
                    if (!mesh.material.uniforms[p.name]) {
                        // –°–æ–∑–¥–∞–µ–º
                        let val;
                        if (p.type === 'float') val = p.val;
                        else if (p.type === 'float2') val = new THREE.Vector2(...p.val);
                        else if (p.type === 'float3') val = new THREE.Vector3(...p.val);
                        else if (p.type === 'float4') val = new THREE.Vector4(...p.val);
                        else if (p.type === 'Texture2D') val = new THREE.Texture();
                        
                        mesh.material.uniforms[p.name] = { value: val };
                    }
                });
                
                mesh.material.needsUpdate = true;
                log("Shader compiled successfully", "success");
            } catch(e) {
                log("Error: " + e.message, "error");
            }
        }
        document.getElementById('status-bar').innerText = "Compiled: " + new Date().toLocaleTimeString();
    }

    function updateUI(params) {
        const container = document.getElementById('paramsContainer');
        // –û—á–∏—â–∞–µ–º UI —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —Å–æ—Å—Ç–∞–≤ –∏–Ω–ø—É—Ç–æ–≤ –∏–∑–º–µ–Ω–∏–ª—Å—è, —á—Ç–æ–±—ã –Ω–µ –¥–µ—Ä–≥–∞–ª–æ—Å—å.
        // –ù–æ –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –ø–æ–∫–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º, –Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –≤ activeParams
        container.innerHTML = "";
        
        params.forEach(p => {
            const row = document.createElement('div');
            row.className = 'param-row';
            let label = `<div class="param-info"><span class="param-type-tag">${p.type}</span><span class="param-label" title="${p.name}">${p.name}</span></div>`;
            
            if (p.type === 'float') {
                const val = activeParams[p.name] !== undefined ? activeParams[p.name] : p.val;
                activeParams[p.name] = val; // Sync
                
                // –û–±–Ω–æ–≤–ª—è–µ–º uniform, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ —ç—Ç–æ –ø–µ—Ä–≤–∞—è –∫–æ–º–ø–∏–ª—è—Ü–∏—è)
                if(mesh && mesh.material.uniforms[p.name]) mesh.material.uniforms[p.name].value = val;

                row.innerHTML = `${label}<input type="range" min="0" max="10" step="0.01" value="${val}" id="rng_${p.name}"><input type="text" class="num-input" value="${val}" id="num_${p.name}">`;
                const rng = row.querySelector(`#rng_${p.name}`), num = row.querySelector(`#num_${p.name}`);
                const sync = (v) => { 
                    if(mesh && mesh.material.uniforms[p.name]) mesh.material.uniforms[p.name].value = v; 
                    activeParams[p.name] = v; 
                    rng.value = v; 
                    num.value = v; 
                }
                rng.oninput = (e) => sync(parseFloat(e.target.value));
                num.onchange = (e) => sync(parseFloat(e.target.value));
            } 
            else if (p.type === 'float3') {
                row.innerHTML = `${label}<input type="color">`;
                row.querySelector('input').oninput = (e) => {
                    const c = new THREE.Color(e.target.value);
                    if(mesh && mesh.material.uniforms[p.name]) mesh.material.uniforms[p.name].value.set(c.r, c.g, c.b);
                    activeParams[p.name] = new THREE.Vector3(c.r, c.g, c.b);
                };
            } 
            else if (p.type === 'float2' || p.type === 'float4') {
                let html = `<div class="vec-input-group">`;
                const dims = p.type === 'float2' ? 2 : 4;
                for(let i=0; i<dims; i++) {
                    // –ë–µ—Ä–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑ activeParams –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –¥–µ—Ñ–æ–ª—Ç
                    let currentVal = p.val[i];
                    // (–¢—É—Ç –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–æ–≤ –≤ activeParams, –Ω–æ –¥–ª—è –∫—Ä–∞—Ç–∫–æ—Å—Ç–∏ –æ–ø—É—Å—Ç–∏–º)
                    html += `<input type="text" class="num-input" value="${currentVal}" data-idx="${i}">`;
                }
                html += `</div>`;
                row.innerHTML = `${label}${html}`;
                
                row.querySelectorAll('input').forEach(inp => {
                    inp.onchange = (e) => {
                        const idx = parseInt(e.target.getAttribute('data-idx'));
                        const val = parseFloat(e.target.value);
                        if(mesh && mesh.material.uniforms[p.name]) {
                           if (mesh.material.uniforms[p.name].value.setComponent) {
                               mesh.material.uniforms[p.name].value.setComponent(idx, val);
                           }
                        }
                    };
                });
            }
            else {
                row.innerHTML = `${label}<input type="file" accept="image/*">`;
                row.querySelector('input').onchange = (e) => {
                    const tex = new THREE.TextureLoader().load(URL.createObjectURL(e.target.files[0]));
                    if(mesh && mesh.material.uniforms[p.name]) mesh.material.uniforms[p.name].value = tex;
                    log(`Texture loaded: ${p.name}`, "info");
                };
            }
            container.appendChild(row);
        });
    }

    function copyUEInputs() {
        const str = "(" + currentInputs.map(p => `(InputName="${p.name}")`).join(",") + ")";
        navigator.clipboard.writeText(str).then(() => {
            log("Inputs copied to clipboard", "success");
        });
    }

    function copyUECode() {
        navigator.clipboard.writeText(lastCleanUECode).then(() => {
            log("Code copied to clipboard", "success");
        });
    }

    function onResize() {
        renderer.setSize(window.innerWidth - 500, window.innerHeight);
        camera.aspect = (window.innerWidth - 500) / window.innerHeight;
        camera.updateProjectionMatrix();
    }

    function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();
        if (mesh && mesh.material && mesh.material.uniforms.u_time) {
            mesh.material.uniforms.u_time.value = (Date.now() - startTime)/1000;
        }
        renderer.render(scene, camera);
    }

    function changeMesh() {
        const type = document.getElementById('shapeSelect').value;
        createMesh(type);
        processAndCompile();
    }

    init();
    animate();
</script>
</body>
</html>